" Initialisation
" {{{

  set nocompatible

  let s:has_ag  = executable('ag')
  let s:has_ack = executable('ack')

  " load all bundles
  runtime bundle/pathogen/autoload/pathogen.vim
  let g:pathogen_disabled = []

  " session doesn't work with minibufexpl
  call add(g:pathogen_disabled, 'session')

  " neocomplcache requires Vim 7.2
  if v:version < '702'
    call add(g:pathogen_disabled, 'neocomplcache')
  endif

  " Powerline requires Vim 7.3 and Python
  if v:version < '703' || !has('python')
    call add(g:pathogen_disabled, 'powerline')
  endif

  " Disable neocomplcache for SSH sessions
  if $SSH_CONNECTION != ""
    call add(g:pathogen_disabled, 'neocomplcache')
  endif

  " load all plugins
  call pathogen#infect()

  if has('gui_running')
    " avoid loading the menu, has to be set before loading filetypes
    set guioptions+=M
  end

  " file handling
  set nobackup
  set autowrite
  set encoding=utf-8
  set modeline
  set modelines=2
  if v:version > '703'
    set cryptmethod=blowfish
  end

  set directory=~/.vim/tmp/swap//,.,/var/tmp//,/tmp//

  " create temporary directory in ~/.vim/tmp
  let s:tmpdir = expand("~/.vim/tmp")
  if !isdirectory(s:tmpdir)
    call mkdir(s:tmpdir, 'p')
  endif

  " enable persistent undo
  if has('persistent_undo')
    set undofile
    set undodir=~/.vim/tmp/undo

    if !isdirectory(&undodir)
      call mkdir(&undodir, 'p')
    endif
  endif

  " interface
  set hidden
  set lazyredraw
  set splitbelow
  set splitright
  set scrolloff=5
  set sidescrolloff=8
  set sidescroll=1
  set virtualedit+=block
  set nostartofline
  set display+=lastline

  " command prompt and status line
  set showcmd
  set ruler
  set laststatus=2
  set history=1000
  set report=0
  set wildmenu
  set wildmode=longest:full,full
  set wildignore=*.pyc,*.o,*.lo,*.la,*.exe,*.swp,*.db,*.bak,*.old,*.dat,*.,tmp,*.mdb,*~,~*

  " searching
  set ignorecase
  set smartcase
  set incsearch
  set hlsearch

" }}}

" Display Settings
" {{{

  " syntax highlighting
  syntax on
  if has('conceal')
    set conceallevel=2
  end

  " color scheme
  colorscheme desertink

  " visual bell
  set visualbell
  set errorbells

  " statusline
  " {{{
  if index(g:pathogen_disabled, 'powerline') > -1
    autocmd VimEnter,Colorscheme * highlight StatusLineGray  cterm=bold ctermfg=231 ctermbg=241 gui=bold guifg=white guibg=#666666
    autocmd VimEnter,Colorscheme * highlight StatusLineRed   cterm=bold ctermfg=231 ctermbg=88 gui=bold guifg=white guibg=#913d3b
    autocmd VimEnter,Colorscheme * highlight StatusLineGreen cterm=bold ctermfg=231 ctermbg=28 gui=bold guifg=white guibg=#368736

    set statusline=

    set stl+=%#StatusLineGray#\ %n\ %*              " buffer number
    set stl+=%#StatusLineGreen#%{fugitive#statusline()[4:-2]}%* " Git status
    set stl+=%#StatusLineRed#%r%*                   " read-only flag
    set stl+=%#StatusLineRed#%m%*                   " modified flag
    " if $SSH_CONNECTION != ""
    "   set stl+=%{toupper(hostname())}:              " hostname
    " endif
    set stl+=\ %<\"%f\"\                            " file name
    set stl+=%y                                     " file type
    set stl+=[%{strlen(&fenc)?&fenc:&enc}           " file encoding
    set stl+=%{&bomb?',BOM':''}                     " BOM flag
    set stl+=%{&ff!='unix'?','.toupper(&ff):''}]\   " file format
    set stl+=%=                                     " left/right separator
    set stl+=%-20.(%l/%L,%c%)\ %P                   " cursor position
  endif
  " }}}

  " line numbers
  set number
  set numberwidth=6

  " cursor line
  autocmd CursorHold *
    \ if &buftype != 'quickfix' && bufname('%') != '-MiniBufExplorer-' | setlocal cursorline | endif
  autocmd CursorMoved,InsertEnter,BufLeave *
    \ if &l:cursorline | setlocal nocursorline | endif

  " highlight trailing whitespace
  autocmd VimEnter,Colorscheme * highlight Whitespace ctermbg=236 guibg=#333333
  autocmd VimEnter,Colorscheme * match Whitespace /\s\+$/

  " go to last cursor position when opening files
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") && &ft != 'gitcommit'
                          \| exe "normal g'\"" | endif

  " window titles
  set title
  if match($TERM, '^screen-') == 0
    set t_ts=k
    set t_fs=\
  endif

  if $STY
    set titlestring=%t\ %m
  else
    "set titlestring=%r%m\ %t\ \[%{substitute(expand('%:p:h'),\ $HOME,\ '~',\ 'g')}\]\ -\ %{v:servername}
  endif

  " disable preview window for completion
  set completeopt-=preview

" }}}

" Text Formatting
" {{{

  set selection=inclusive
  set backspace=indent,eol,start
  set whichwrap+=<,>,[,],h,l

  " indents
  filetype plugin indent on
  set autoindent
  set smartindent
  set nocindent

  " avoid auto-indenting hash signs
  inoremap # x<C-H>#

  " tabs
  set noexpandtab
  set smarttab
  set shiftround

  " matching
  set matchpairs=(:),{:},[:],<:>
  set showmatch
  runtime macros/matchit.vim
  let b:match_ignorecase = 1

  " diffing
  "set diffopt+=iwhite

  " folding
  set foldenable foldmethod=marker
  "autocmd Syntax * set foldmethod=marker

" }}}

" Filetype Settings
" {{{

  autocmd FileType alsaconf,applescript,asm,autoit,coffee,context,css,dot,eruby,html,io,javascript,lisp,markdown,ocaml,perl,php,puppet,smarty,sql,plaintex,ruby,scss,sh,svn,tex,text,textile,vb,vim,xhtml,xml,xslt,yaml setlocal ts=2 sts=2 sw=2 expandtab nocindent
  autocmd FileType c,cs,cpp,php setlocal ts=3 sts=3 sw=3 expandtab
  autocmd FileType python,lua,sshconfig setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType apache setlocal ts=4 sts=4 sw=4
  autocmd FileType mail setlocal ts=2 sts=2 sw=2 expandtab tw=80 lbr
  autocmd FileType tex,plaintex,context setlocal lbr
  autocmd FileType gitcommit,gitrebase setlocal colorcolumn=50,72
  autocmd FileType crontab setlocal nobackup nowritebackup

  autocmd BufNewFile,BufRead *.md setf markdown
  autocmd BufNewFile,BufRead */bin/*.run setf sh
  autocmd BufNewFile,BufRead *.inc,*.thtml setf php
  autocmd BufNewFile,BufRead *.boo setf python
  autocmd BufNewFile,BufRead Gemfile,*.plan setf ruby
  autocmd BufNewFile,BufRead ~/.devilspie/* setf lisp
  autocmd BufNewFile,BufRead *.pac setf javascript

  " Ruby syntax highlighting
  let g:ruby_operators = 1

  " Ruby auto-completion
  let g:rubycomplete_rails = 1
  let g:rubycomplete_buffer_loading = 1

  " force initialisation of the ruby environment to avoid stack errors
  if has('ruby')
    silent! ruby nil
  endif

  " PHP syntax highlighting
  let php_htmlInStrings = 1
  let php_baselib = 1
  let php_special_functions = 1
  let php_alt_comparisons = 1
  let php_alt_AssignByReference = 1
  let php_folding = 1

" }}}

" Commands
" {{{

  " ignore case for common commands
  command! -nargs=? -bang -complete=file E e<bang> <args>
  command! -nargs=? -bang -complete=file W w<bang> <args>
  command! -nargs=? -bang -complete=file WQ wq<bang> <args>
  command! -bang Q q<bang>
  command! -bang QA qa<bang>
  command! -bang Qa qa<bang>

  " shortcuts for visual mode
  command! Dg diffget
  command! Dp diffput

  " shortcut to google something
  if has('mac')
    let g:open_command = 'open'
  elseif has('unix')
    let g:open_command = 'xdg-open'
  else
    let g:open_command = 'start'
  end
  command! -nargs=+ Google call system(g:open_command.' "https://www.google.com/search?q=<args>"')
  command! -nargs=+ Wikipedia call system(g:open_command.' "http://en.wikipedia.org/wiki/Special:Search?search=<args>"')

  " shortcut to edit vim config files
  function! VimConfigFileCompletion(A, L, P) " {{{
    let l:dir = getcwd()
    chdir ~/.dotfiles/vim/

    if isdirectory(a:A) && a:A[-1:] != '/'
      let l:arg = a:A.'/'
    else
      let l:arg = a:A
    endif

    let l:values = split(glob(l:arg.'*',), "\n")
    if len(l:values) == 1 && isdirectory(l:values[0])
      let l:values = [ l:values[0].'/' ]
    endif

    execute "chdir ".l:dir
    return l:values
  endfunction " }}}
  command! -nargs=1 -complete=customlist,VimConfigFileCompletion RC edit ~/.dotfiles/vim/<args>

" }}}

" Keybindings
" {{{

  " shortcut for desktop clipboard
  noremap + "+

  " don't use exact searches for */#
  noremap * g*
  noremap # g#

  " repeat command for each line in selection
  vnoremap . :normal .<CR>

  " shortcuts for diff
  nnoremap du :diffupdate<CR>
  nnoremap dj ]c
  nnoremap dk [c

  " map Ctrl+C to Escape
  inoremap <C-c> <Esc>

  " indent with Tab/Shift+Tab in visual mode
  vmap <Tab> >
  vmap <S-Tab> <

  " reselect visual block after indent
  vnoremap > >gv
  vnoremap < <gv

  " toggle paste mode with F12
  set pastetoggle=<f12>

  " emacs keybindings
  cnoremap <C-a> <Home>
  cnoremap <C-e> <End>

  " scroll in insert mode
  inoremap <C-e> <C-o><C-e>
  inoremap <C-y> <C-o><C-y>

  " autocomplete search history in command mode
  cnoremap <C-n> <Up>
  cnoremap <C-p> <Down>

  " switch buffers with Shift+Tab / Ctrl+Shift+Tab
  noremap <C-Tab> :MBEbn<CR>
  noremap <C-S-Tab> :MBEbp<CR>

  " navigate windows with Ctrl+jkhl
  noremap <C-j> <C-w>j
  noremap <C-k> <C-w>k
  noremap <C-h> <C-w>h
  noremap <C-l> <C-w>l

  " ,q / ,e - toggle quickfix window and location list
  function! GetBufferList()
    redir =>buflist
    silent! ls
    redir END
    return buflist
  endfunction

  function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
      if bufwinnr(bufnum) != -1
        exec(a:pfx.'close')
        return
      endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location List is Empty."
        return
    endif
    let winnr = winnr()
    exec(a:pfx.'open')
    if winnr() != winnr
      wincmd p
    endif
  endfunction

  nnoremap <silent> ,q :call ToggleList('Quickfix List', 'c')<CR>
  nnoremap <silent> ,e :call ToggleList('Location List', 'l')<CR>

  " resize quickfix windows to their content, or 20 lines maximum
  function! ResizeWindow(min, max)
    let l:max = min([a:max, &lines / 3])
    execute max([a:min, min([l:max, line('$') + 1])]).'wincmd _'
  endfunction
  autocmd FileType qf call ResizeWindow(2, 20)

  " ,/, F2 - remove highlighted search
  nnoremap <silent> ,/ :noh<CR>
  nnoremap <silent> <F2> :noh<CR>

  " ,1-9 - quick buffer switching
  nnoremap <silent> ,1 :b1<CR>
  nnoremap <silent> ,2 :b2<CR>
  nnoremap <silent> ,3 :b3<CR>
  nnoremap <silent> ,4 :b4<CR>
  nnoremap <silent> ,5 :b5<CR>
  nnoremap <silent> ,6 :b6<CR>
  nnoremap <silent> ,7 :b7<CR>
  nnoremap <silent> ,8 :b8<CR>
  nnoremap <silent> ,9 :b9<CR>

  " ,c - close current window
  nnoremap <silent> ,c :silent! close<CR>

  " ,d - open definition in new window
  nmap <silent> ,d <C-w>f

  " ,g - grep the current file
  if s:has_ag
    let &grepprg = "ag --smart-case --nogroup"
  elseif s:has_ack
    let &grepprg = "ack --smart-case --noheading --with-filename --column"
  endif

  function! GrepCurrentFile()
    if expand('%') == ''
      echo "Can't grep unsaved file."
      return
    endif

    echohl ModeMsg
    let l:pattern = substitute(input("Grep file: /", expand('<cword>')), '"', '\"', '')

    if l:pattern != ""
      echohl ModeMsg
      echo "/ searching..."
      execute 'silent grep '.shellescape(l:pattern).' %'

      let l:len = len(getqflist())
      if l:len > 0
        copen
        redraw
        echo l:len l:len == 1 ? "match" : "matches" "found"
      else
        echohl ErrorMsg
        echo "Pattern not found in current file: ".l:pattern
      endif
    endif

    echohl None
  endfunction
  nnoremap <silent> ,g :call GrepCurrentFile()<CR>

  " ,G - grep the current path
  function! GrepCurrentPath() " {{{
    echohl Question
    let l:pattern = substitute(input("Grep path: /", expand('<cword>')), '"', '\"', '')

    if l:pattern != ""
      if exists('b:rails_root')
        let l:path = b:rails_root.'/{app,config,lib,vendor/plugins,public/javascripts,public/stylesheets}'
      else
        let l:path = '.'
      endif

      echohl Question
      echo "/ searching..."
      execute 'silent grep -r '.shellescape(l:pattern).' '.l:path

      let l:len = len(getqflist())
      if l:len > 0
        copen
        redraw
        echo l:len l:len == 1 ? "match" : "matches" "found"
      else
        echohl ErrorMsg
        echo "Pattern not found in current path: ".l:pattern
      endif
    endif

    echohl None
  endfunction " }}}
  nnoremap <silent> ,G :call GrepCurrentPath()<CR>

  " ,n - next buffer
  nnoremap <silent> ,n :bnext<CR>

  " ,N - toggle line numbers
  function! ToggleLineNumbers() " {{{
    if &number
      set nonumber
    elseif !exists('&relativenumber') || &relativenumber
      set number
    else
      set relativenumber
    endif
  endfunction " }}}
  nnoremap <silent> ,N :call ToggleLineNumbers()<CR>

  " ,p - previous buffer
  nnoremap <silent> ,p :bprevious<CR>

  " ,r - reload current buffer
  nnoremap <silent> ,r :edit<CR>

  " ,R - reload vimrc
  nnoremap <silent> ,R :runtime! vimrc gvimrc<CR>:let &ft=&ft<CR>:nohlsearch<CR>

  " ,s - split horizontally
  nnoremap <silent> ,s :split<CR>

  " ,v - split vertically
  nnoremap <silent> ,v :vsplit<CR>

  " ,w - write file
  nnoremap <silent> ,w :write<CR>

  " ,W - clear trailing whitespace
  nnoremap <silent> ,W mw:%s/\s\s*$//e<CR>:nohlsearch<CR>`w:echohl Question<CR>:echo "Trailing whitespace cleared"<CR>:echohl none<CR>

  " F4 / F5 - change window height
  nnoremap <silent> <F4> <C-w>+
  imap <silent> <F4> <C-o><F4>
  nnoremap <silent> <F5> <C-w>-
  imap <silent> <F5> <C-o><F5>

  " F6 / F7 - change window width
  nnoremap <silent> <F6> <C-w>>
  imap <silent> <F6> <C-o><F6>
  nnoremap <silent> <F7> <C-w><
  imap <silent> <F7> <C-o><F7>

" }}}

" Plugin Settings
" {{{

  runtime ftplugin/man.vim

  " rails
  hi! link rubyRailsARMethod Statement

  " undotree
  nnoremap <silent> ,u :UndotreeToggle<CR>

  " closetag
  autocmd BufEnter * runtime scripts/closetag.vim
  let g:closetag_html_style = 'html'

  " tcomment
  let g:tcomment_types = {'php': {'commentstring_rx': '\%%(//\|#\) %s', 'commentstring': '# %s'}}

  " tabular
  noremap ,a :Tabular /
  noremap ,a, :Tabular /, /l0<CR>
  noremap ,a{ :Tabular /{<CR>
  noremap ,a} :Tabular /}<CR>
  noremap ,a= :Tabular /=<CR>
  noremap ,a> :Tabular /=><CR>
  noremap ,a: :Tabular /:/l0r1<CR>

  " syntax attributes
  runtime scripts/SyntaxAttr.vim
  nnoremap <silent> ,S :call SyntaxAttr()<CR>

  " session plugin
  let g:session_directory = "~/.vim/tmp/sessions"
  let g:session_autosave = 'yes'

  " indent object
  autocmd VimEnter * omap <silent>ai aI
  autocmd VimEnter * vmap <silent>ai aI

  " unimpaired
  vmap <C-a> [egv
  vmap <C-z> ]egv

  " unite
  if index(g:pathogen_disabled, 'unite') == -1
    let g:unite_data_directory = '~/.vim/tmp/unite'
    let g:unite_source_rec_max_cache_files = 5000
    let g:unite_source_file_mru_long_limit = 5000
    let g:unite_source_history_yank_enable = 1

    " speed up recursive file searches
    if s:has_ag
      let g:unite_source_rec_async_command = 'ag -l .'
    elseif s:has_ack
      let g:unite_source_rec_async_command = 'ack -f --nofilter'
    end

    " enable fuzzy matching for all sources
    call unite#filters#matcher_default#use(['matcher_fuzzy'])

    " sort results by match rank
    call unite#filters#sorter_default#use(['sorter_rank'])

    " only show the 5 most recently edited files
    call unite#custom#source('file_mru', 'max_candidates', 10)

    function! s:unite_buffers()
      " use ; to leave insert mode
      inoremap <silent><buffer> ; <Esc>

      " use <Tab> to narrow down paths and open files
      nmap <silent><buffer> <Tab> <Plug>(unite_do_default_action)
      imap <silent><buffer> <Tab> <Plug>(unite_do_default_action)

      " use <C-a> to choose custom actions
      nmap <silent><buffer> <C-a> <Plug>(unite_choose_action)
      imap <silent><buffer> <C-a> <Plug>(unite_choose_action)

      " use <C-c> to close Unite
      nmap <silent><buffer> <C-c> :call unite#all_quit_session()<CR>
      imap <silent><buffer> <C-c> <Esc>:call unite#all_quit_session()<CR>
    endfunction

    " automatically map the above keys in all Unite buffers
    autocmd FileType unite call s:unite_buffers()

    function! UniteWrapper(action, arguments)
      return ":\<C-u>Unite -no-split " . a:action . " " . a:arguments . "\<CR>"
    endfunction

    " <Space> - switch buffers, open most recently edited files, and recursively find files in the current project root
    nnoremap <silent><expr> <Space> UniteWrapper('buffer file_mru:all file_rec/async:!', '-start-insert')

    " ,f - open a file using shell-style directory completion, using the current file's directory as starting point
    nnoremap <silent><expr> ,f UniteWrapper('file' . (expand('%') == '' ? '' : ':%:h'), '-start-insert')

    " ,y - show yank history
    nnoremap <silent><expr> ,y UniteWrapper('history/yank', '')

    " ,t - show outline
    nnoremap <silent><expr> ,t UniteWrapper('outline', '-start-insert')
  end

  " indent guides
  " {{{
  let g:indent_guides_enable_on_vim_startup = 1
  let g:indent_guides_auto_colors = 0
  let g:indent_guides_exclude_filetypes = [ 'text', 'conf', 'help', 'man', 'minibufexpl', 'unite' ]
  autocmd VimEnter,Colorscheme * highlight IndentGuidesOdd  ctermbg=235 guibg=#2a2a2a
  autocmd VimEnter,Colorscheme * highlight IndentGuidesEven ctermbg=236 guibg=#333333
  " }}}

  " syntastic
  " {{{
  let g:syntastic_check_on_open = 1
  let g:syntastic_enable_signs = 1

  let g:syntastic_javascript_checkers = [ 'jshint' ]
  let g:syntastic_php_checkers = [ 'php', 'phpmd' ]
  let g:syntastic_sh_checkers = [ 'sh' ]

  let g:syntastic_puppet_lint_arguments = '--no-documentation-check'

  if !&diff
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_auto_jump = 0
  endif
  " }}}

  " powerline
  " {{{
  if index(g:pathogen_disabled, 'powerline') == -1
    set runtimepath+=~/.dotfiles/vim/bundle/powerline/powerline/bindings/vim

    " terminal tweaks
    if !has('gui_running')
      " {{{
      let g:powerline_theme_overrides__default = {
        \ 'segment_data': {
          \ 'branch': { 'before': "@ " },
          \ 'line_current_symbol': { 'contents': "" },
          \ 'readonly_indicator': { 'args': { 'text': '#'} }
        \ }
      \ }

      let g:powerline_config_overrides = {
        \ "common": {
          \ "dividers": {
            \ "left":  { "hard": " ", "soft": "> " },
            \ "right": { "hard": " ", "soft": " <" }
          \ }
        \ }
      \ }
      " }}}
    end
  end
  " }}}

  " netrw
  " {{{
  let g:netrw_silent = 1
  let g:netrw_ftpmode = 'ascii'
  let g:netrw_longlist = 1
  let g:netrw_winsize = 40
  let g:netrw_altv = 1
  let g:DrChipTopLvlMenu = 'Plugins.'
  if has('unix') && exists("$DISPLAY")
    let g:netrw_browsex_viewer = 'xdg-open'
  endif
  " }}}

  " minibufexplorer
  " {{{
  let g:miniBufExplSplitBelow = 0
  let g:miniBufExplUseSingleClick = 1
  let g:miniBufExplTabWrap = 1
  let g:miniBufExplSetUT = 1

  highlight link MBENormal Comment
  highlight MBEVisibleNormal ctermbg=22 guibg=#265f26
  highlight MBEVisibleActiveNormal cterm=bold ctermbg=28 gui=bold guibg=#368736
  highlight MBEVisibleActiveChanged cterm=bold ctermbg=124 gui=bold guibg=#cc5653
  highlight MBEVisibleChanged ctermbg=88 guibg=#913d3b
  highlight MBEChanged ctermbg=88 guibg=#913d3b
  let g:did_minibufexplorer_syntax_inits = 1
  " }}}

  " neocomplcache
  " {{{
  if index(g:pathogen_disabled, 'neocomplcache') == -1
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_enable_auto_select = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_auto_completion_start_length = 2

    let g:neocomplcache_source_disable = {
      \ 'syntax_complete': 1,
    \ }

    if !exists('g:neocomplcache_omni_patterns')
      let g:neocomplcache_omni_patterns = {}
    endif

    let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
    let g:neocomplcache_omni_patterns.php  = '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
    let g:neocomplcache_omni_patterns.c    = '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
    let g:neocomplcache_omni_patterns.cpp  = '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=neocomplcache#smart_close_popup()<CR><CR>
    " <TAB>: completion.
    inoremap <expr> <TAB> pumvisible() ? "\<C-y>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr> <C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr> <BS>  neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr> <C-y> neocomplcache#close_popup()
    inoremap <expr> <C-e> neocomplcache#cancel_popup()
  endif
  " }}}

" }}}
