" Initialisation
" {{{

  set nocompatible
  let $LANG = "en"

  " load all bundles
  runtime bundle/pathogen/autoload/pathogen.vim
  let g:pathogen_disabled = []

  " session doesn't work with minibufexpl
  call add(g:pathogen_disabled, 'session')

  " TODO delete these?
  call add(g:pathogen_disabled, 'conque')
  call add(g:pathogen_disabled, 'nerdtree')
  "call add(g:pathogen_disabled, 'yankring')

  " Powerline and neocomplcache require Vim 7.2
  if v:version < '702'
    call add(g:pathogen_disabled, 'powerline')
    call add(g:pathogen_disabled, 'neocomplcache')
    call add(g:pathogen_disabled, 'neosnippets')
  endif

  " FuzzyFinder/L9 require Vim 7.2 and floating-point support
  if v:version < '702' || !has('float')
    call add(g:pathogen_disabled, 'l9')
    call add(g:pathogen_disabled, 'fuzzyfinder')
  endif

  " Gundo requires Vim 7.3 and Python
  if v:version < '703' || !has('python')
    call add(g:pathogen_disabled, 'gundo')
  endif

  " Disable neocomplcache for SSH sessions
  if $SSH_CONNECTION != ""
    call add(g:pathogen_disabled, 'neocomplcache')
    call add(g:pathogen_disabled, 'neosnippets')
  endif

  " Load all plugins
  call pathogen#infect()

  if has('gui_running')
    " avoid loading the menu, has to be set before loading filetypes
    set guioptions+=M
  end

  " file handling
  set nobackup
  set autowrite
  set encoding=utf-8
  set modeline
  set modelines=2
  if v:version > '703'
    set cryptmethod=blowfish
  end

  set directory=~/.vim/tmp/swap//,.,/var/tmp//,/tmp//

  " create temporary directory in ~/.vim/tmp
  let s:tmpdir = expand("~/.vim/tmp")
  if !isdirectory(s:tmpdir)
    call mkdir(s:tmpdir, 'p')
  endif

  " enable persistent undo
  if has('persistent_undo')
    set undofile
    set undodir=~/.vim/tmp/undo

    if !isdirectory(&undodir)
      call mkdir(&undodir, 'p')
    endif
  endif

  " interface
  set hidden
  set lazyredraw
  set splitbelow
  set splitright
  set scrolloff=5
  set virtualedit+=block
  set nostartofline
  set display+=lastline

  " command prompt and status line
  set showcmd
  set ruler
  set laststatus=2
  set history=1000
  set report=0
  set wildmenu
  set wildmode=longest:full,full
  set wildignore=*.pyc,*.o,*.lo,*.la,*.exe,*.swp,*.db,*.bak,*.old,*.dat,*.,tmp,*.mdb,*~,~*

  " searching
  set ignorecase
  set smartcase
  set incsearch
  set hlsearch

" }}}

" Display Settings
" {{{

  if &term == 'screen-bce'
    " enable 256 color support for screen
    set t_Co=256

    " don't clear screen on exit
    "set t_ti=
    "set t_te=
  endif

  " syntax highlighting
  syntax on
  if has('conceal')
    set conceallevel=2
  end

  " color scheme
  colorscheme desertink

  " visual bell
  set visualbell
  set errorbells

  " statusline
  " {{{
  if index(g:pathogen_disabled, 'powerline') > -1
    autocmd VimEnter,BufRead,BufNewFile * highlight StatusLineGray  cterm=bold ctermfg=231 ctermbg=241 gui=bold guifg=white guibg=#666666
    autocmd VimEnter,BufRead,BufNewFile * highlight StatusLineRed   cterm=bold ctermfg=231 ctermbg=88 gui=bold guifg=white guibg=#913d3b
    autocmd VimEnter,BufRead,BufNewFile * highlight StatusLineGreen cterm=bold ctermfg=231 ctermbg=28 gui=bold guifg=white guibg=#368736

    set statusline=

    set stl+=%#StatusLineGray#\ %n\ %*              " buffer number
    set stl+=%#StatusLineGreen#%{fugitive#statusline()[4:-2]}%* " Git status
    set stl+=%#StatusLineRed#%r%*                   " read-only flag
    set stl+=%#StatusLineRed#%m%*                   " modified flag
    " if $SSH_CONNECTION != ""
    "   set stl+=%{toupper(hostname())}:              " hostname
    " endif
    set stl+=\ %<\"%f\"\                            " file name
    set stl+=%y                                     " file type
    set stl+=[%{strlen(&fenc)?&fenc:&enc}           " file encoding
    set stl+=%{&bomb?',BOM':''}                     " BOM flag
    set stl+=%{&ff!='unix'?','.toupper(&ff):''}]\   " file format
    set stl+=%=                                     " left/right separator
    set stl+=%-20.(%l/%L,%c%)\ %P                   " cursor position
  endif
  " }}}

  " line numbers
  set relativenumber
  set numberwidth=6

  " cursor line
  autocmd CursorHold *
    \ if &buftype != 'quickfix' && bufname('%') != '-MiniBufExplorer-' | setlocal cursorline | endif
  autocmd CursorMoved,InsertEnter,BufLeave *
    \ if &l:cursorline | setlocal nocursorline | endif

  " highlight trailing whitespace
  autocmd VimEnter,BufRead,BufNewFile * highlight Whitespace ctermbg=236 guibg=#333333
  autocmd VimEnter,BufRead,BufNewFile * match Whitespace /\s\+$/

  " go to last cursor position when opening files
  autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") && &ft != 'gitcommit'
                          \| exe "normal g'\"" | endif

  " window titles
  set title
  if &term == 'screen-bce' || &term == 'rxvt-unicode'
    set t_ts=k
    set t_fs=\
  endif

  if $STY
    set titlestring=%t\ %m
  else
    "set titlestring=%r%m\ %t\ \[%{substitute(expand('%:p:h'),\ $HOME,\ '~',\ 'g')}\]\ -\ %{v:servername}
  endif

" }}}

" Text Formatting
" {{{

  set selection=inclusive
  set backspace=indent,eol,start
  set whichwrap+=<,>,[,],h,l

  " indents
  filetype plugin indent on
  set autoindent
  set smartindent
  set nocindent

  " avoid auto-indenting pound signs
  inoremap # x<C-H>#

  " tabs
  set noexpandtab
  set smarttab
  set shiftround

  " matching
  set showmatch
  runtime macros/matchit.vim
  let b:match_ignorecase = 1

  " diffing
  set diffopt+=iwhite

  " folding
  set foldenable foldmethod=marker
  "autocmd Syntax * set foldmethod=marker

" }}}

" Filetype Settings
" {{{

  autocmd FileType alsaconf,applescript,asm,autoit,context,css,dot,eruby,html,io,javascript,lisp,markdown,ocaml,perl,php,puppet,smarty,sql,plaintex,ruby,sh,svn,tex,textile,vb,vim,xhtml,xml,xslt,yaml setlocal ts=2 sts=2 sw=2 expandtab nocindent
  autocmd FileType c,cs,cpp,php setlocal ts=3 sts=3 sw=3 expandtab
  autocmd FileType python,lua,sshconfig setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType apache setlocal ts=4 sts=4 sw=4
  autocmd FileType mail setlocal ts=2 sts=2 sw=2 expandtab tw=80 lbr
  autocmd FileType tex,plaintex,context setlocal lbr
  autocmd FileType gitcommit,gitrebase setlocal colorcolumn=50,72

  autocmd BufEnter *.md setf markdown
  autocmd BufEnter */bin/*.run setf sh
  autocmd BufEnter *.inc,*.thtml setf php
  autocmd BufEnter *.boo setf python
  autocmd BufEnter Gemfile,*.plan setf ruby
  autocmd BufEnter ~/.devilspie/* setf lisp
  autocmd BufEnter *.pac setf javascript

  " Ruby syntax highlighting
  let g:ruby_operators = 1

  " Ruby auto-completion
  let g:rubycomplete_rails = 1
  let g:rubycomplete_buffer_loading = 1

  " force initialisation of the ruby environment to avoid stack errors
  if has('ruby')
    silent! ruby nil
  endif

  " PHP syntax highlighting
  let php_htmlInStrings = 1
  let php_baselib = 1
  let php_special_functions = 1
  let php_alt_comparisons = 1
  let php_alt_AssignByReference = 1
  let php_folding = 1

  " Ruby block auto-completion
  " {{{
  " function! RubyEndToken()
  "   let current_line = getline( '.' )
  "   let braces_at_end = '{\s*\(|\(,\|\s\|\w\)*|\s*\)\?$'
  "   let brackets_at_end = '[\s*\(|\(,\|\s\|\w\)*|\s*\)\?$'
  "   let stuff_without_do = '^\s*\(class\|if\|unless\|begin\|case\|for\|module\|while\|until\|def\)'
  "   let with_do = 'do\s*\(|\(,\|\s\|\w\)*|\s*\)\?$'

  "   if match(current_line, braces_at_end) >= 0
  "     return "\<CR>}\<C-O>O"
  "   elseif match(current_line, brackets_at_end) >= 0
  "     return "\<CR>\1\<C-O>O"
  "   elseif match(current_line, stuff_without_do) >= 0
  "     return "\<CR>end\<C-O>O"
  "   elseif match(current_line, with_do) >= 0
  "     return "\<CR>end\<C-O>O"
  "   else
  "     return "\<CR>"
  "   endif
  " endfunction
  "
  "autocmd FileType ruby inoremap <buffer> <CR> <C-R>=RubyEndToken()<CR>
  " }}}

" }}}

" Commands
" {{{

  " ignore case for common commands
  command! -nargs=? -bang -complete=file E e<bang> <args>
  command! -nargs=? -bang -complete=file W w<bang> <args>
  command! -nargs=? -bang -complete=file WQ wq<bang> <args>
  command! -bang Q q<bang>
  command! -bang QA qa<bang>
  command! -bang Qa qa<bang>

  " shortcuts for visual mode
  command! Dg diffget
  command! Dp diffput

  " shortcut to google something
  if has('mac')
    let g:open_command = 'open'
  elseif has('unix')
    let g:open_command = 'xdg-open'
  else
    let g:open_command = 'start'
  end
  command! -nargs=+ Google call system(g:open_command.' "https://www.google.com/search?q=<args>"')
  command! -nargs=+ Wikipedia call system(g:open_command.' "http://en.wikipedia.org/wiki/Special:Search?search=<args>"')

  " shortcut to edit vim config files
  function! VimConfigFileCompletion(A, L, P) " {{{
    let l:dir = getcwd()
    chdir ~/.dotfiles/vim/

    if isdirectory(a:A) && a:A[-1:] != '/'
      let l:arg = a:A.'/'
    else
      let l:arg = a:A
    endif

    let l:values = split(glob(l:arg.'*',), "\n")
    if len(l:values) == 1 && isdirectory(l:values[0])
      let l:values = [ l:values[0].'/' ]
    endif

    execute "chdir ".l:dir
    return l:values
  endfunction " }}}
  command! -nargs=1 -complete=customlist,VimConfigFileCompletion RC edit ~/.dotfiles/vim/<args>

" }}}

" Keybindings
" {{{

  " don't use exact searches for */#
  noremap * g*
  noremap # g#

  " repeat command for each line in selection
  vnoremap . :normal .<CR>

  " shortcuts for diff
  nnoremap du :diffupdate<CR>
  nnoremap dn ]c

  " map Ctrl+C to Escape
  inoremap <C-c> <Esc>

  " indent with Tab/Shift+Tab in visual mode
  vmap <Tab> >
  vmap <S-Tab> <

  " reselect visual block after indent
  vnoremap > >gv
  vnoremap < <gv

  " toggle paste mode with F12
  set pastetoggle=<f12>

  " emacs keybindings
  cnoremap <C-a> <Home>
  cnoremap <C-e> <End>

  " scroll in insert mode
  inoremap <C-e> <C-o><C-e>
  inoremap <C-y> <C-o><C-y>

  " autocomplete search history in command mode
  cnoremap <C-n> <Up>
  cnoremap <C-p> <Down>

  " ,q / ,e - toggle quickfix window and location list
  function! GetBufferList()
    redir =>buflist
    silent! ls
    redir END
    return buflist
  endfunction

  function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
      if bufwinnr(bufnum) != -1
        exec(a:pfx.'close')
        return
      endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location List is Empty."
        return
    endif
    let winnr = winnr()
    exec(a:pfx.'open')
    if winnr() != winnr
      wincmd p
    endif
  endfunction

  nnoremap <silent> ,q :call ToggleList('Quickfix List', 'c')<CR>
  nnoremap <silent> ,e :call ToggleList('Location List', 'l')<CR>

  " resize quickfix windows to their content, or 20 lines maximum
  function! ResizeWindow(min, max)
    let l:max = min([a:max, &lines / 3])
    execute max([a:min, min([l:max, line('$') + 1])]).'wincmd _'
  endfunction
  autocmd FileType qf call ResizeWindow(2, 20)

  " ,/, F2 - remove highlighted search
  nnoremap <silent> ,/ :noh<CR>
  nnoremap <silent> <F2> :noh<CR>

  " ,1-9 - quick buffer switching
  nnoremap <silent> ,1 :b1<CR>
  nnoremap <silent> ,2 :b2<CR>
  nnoremap <silent> ,3 :b3<CR>
  nnoremap <silent> ,4 :b4<CR>
  nnoremap <silent> ,5 :b5<CR>
  nnoremap <silent> ,6 :b6<CR>
  nnoremap <silent> ,7 :b7<CR>
  nnoremap <silent> ,8 :b8<CR>
  nnoremap <silent> ,9 :b9<CR>

  " ,c - close current window
  nnoremap <silent> ,c :silent! close<CR>

  " ,d - open definition in new window
  nmap <silent> ,d <C-w>f

  " ,F - toggle syntax folding
  function! ToggleFolding()
    if &foldcolumn == 0
      if &filetype == 'python'
        setlocal foldmethod=indent
      else
        setlocal foldmethod=syntax
      endif
      setlocal foldcolumn=3
    else
      setlocal foldcolumn=0 foldmethod=marker
    endif
  endfunction

  nnoremap <silent> ,F :call ToggleFolding()<CR>

  " ,g - grep the current file
  function! GrepCurrentFile()
    if expand('%') == ''
      echo "Can't grep unsaved file."
      return
    endif

    echohl ModeMsg
    let l:pattern = substitute(input("Grep file: /", expand('<cword>')), '"', '\"', '')

    if l:pattern != ""
      echohl ModeMsg
      echo "/ searching..."
      execute 'silent grep '.shellescape(l:pattern).' %'

      let l:len = len(getqflist())
      if l:len > 0
        copen
        redraw
        echo l:len l:len == 1 ? "match" : "matches" "found"
      else
        echohl ErrorMsg
        echo "Pattern not found in current file: ".l:pattern
      endif
    endif

    echohl None
  endfunction
  nnoremap <silent> ,g :call GrepCurrentFile()<CR>

  " ,G - grep the current path
  function! GrepCurrentPath() " {{{
    echohl Question
    let l:pattern = substitute(input("Grep path: /", expand('<cword>')), '"', '\"', '')

    if l:pattern != ""
      if exists('b:rails_root')
        let l:path = b:rails_root.'/{app,config,lib,vendor/plugins,public/javascripts,public/stylesheets}'
      else
        let l:path = '.'
      endif

      echohl Question
      echo "/ searching..."
      execute 'silent grep -r '.shellescape(l:pattern).' '.l:path

      let l:len = len(getqflist())
      if l:len > 0
        copen
        redraw
        echo l:len l:len == 1 ? "match" : "matches" "found"
      else
        echohl ErrorMsg
        echo "Pattern not found in current path: ".l:pattern
      endif
    endif

    echohl None
  endfunction " }}}
  nnoremap <silent> ,G :call GrepCurrentPath()<CR>

  " ,n - next buffer
  nnoremap <silent> ,n :bnext<CR>

  " ,N - toggle line numbers
  function! ToggleLineNumbers() " {{{
    if &number
      set nonumber
    elseif &relativenumber
      set number
    else
      set relativenumber
    endif
  endfunction " }}}
  nnoremap <silent> ,N :call ToggleLineNumbers()<CR>

  " ,p - previous buffer
  nnoremap <silent> ,p :bprevious<CR>

  " ,P - toggle paste
  nnoremap <silent> ,P :set paste!<CR>

  " ,r - reload current buffer
  nnoremap <silent> ,r :edit<CR>

  " ,R - reload vimrc
  nnoremap <silent> ,R :runtime! vimrc gvimrc<CR>:let &ft=&ft<CR>:nohlsearch<CR>

  " ,s - split horizontally
  nnoremap <silent> ,s :split<CR>

  " ,v - split vertically
  nnoremap <silent> ,v :vsplit<CR>

  " ,w - write file
  nnoremap <silent> ,w :write<CR>

  " ,W - clear trailing whitespace
  nnoremap <silent> ,W mw:%s/\s\s*$//e<CR>:nohlsearch<CR>`w:echohl Question<CR>:echo "Trailing whitespace cleared"<CR>:echohl none<CR>

  " F4 / F5 - change window height
  nnoremap <silent> <F4> <C-w>+
  imap <silent> <F4> <C-o><F4>
  nnoremap <silent> <F5> <C-w>-
  imap <silent> <F5> <C-o><F5>

  " F6 / F7 - change window width
  nnoremap <silent> <F6> <C-w>>
  imap <silent> <F6> <C-o><F6>
  nnoremap <silent> <F7> <C-w><
  imap <silent> <F7> <C-o><F7>

" }}}

" Plugin Settings
" {{{

  runtime ftplugin/man.vim

  " rails
  hi! link rubyRailsARMethod Statement

  " gundo
  nnoremap <silent> ,u :GundoToggle<CR>

  " closetag
  autocmd BufEnter * runtime scripts/closetag.vim

  " tcomment
  let g:tcomment_types = {'php': {'commentstring_rx': '\%%(//\|#\) %s', 'commentstring': '# %s'}}

  " syntax attributes
  runtime scripts/SyntaxAttr.vim
  nnoremap <silent> ,S :call SyntaxAttr()<CR>

  " session plugin
  let g:session_directory = "~/.vim/tmp/sessions"
  let g:session_autosave = 'yes'

  " indent object
  autocmd VimEnter * omap <silent>ai aI
  autocmd VimEnter * vmap <silent>ai aI

  " unimpaired
  vmap <C-a> [egv
  vmap <C-z> ]egv

  " fuzzy finder
  " {{{
  nnoremap <silent> ,b :FufBuffer<CR>
  nnoremap <silent> ,f :FufFileWithCurrentBufferDir<CR>
  nnoremap <silent> ,j :FufJumpList<CR>
  nnoremap <silent> ,l :FufLine<CR>
  " }}}

  " indent guides
  " {{{
  let g:indent_guides_auto_colors = 0
  autocmd VimEnter,BufRead,BufNewFile * highlight IndentGuidesOdd  ctermbg=235 guibg=#2a2a2a
  autocmd VimEnter,BufRead,BufNewFile * highlight IndentGuidesEven ctermbg=236 guibg=#333333

  nnoremap <silent> ,i :IndentGuidesToggle<CR>
  " }}}

  " nerd tree
  " {{{
  if index(g:pathogen_disabled, 'nerdtree') == -1
    let g:NERDChristmasTree = 1
    let g:NERDTreeQuitOnOpen = 1
    let g:NERDTreeDirArrows = 1

    nnoremap <silent> ,x :NERDTreeToggle<CR>
  endif
  " }}}

  " conque
  " {{{
  if index(g:pathogen_disabled, 'conque') == -1
    autocmd FileType conque_term match none
    let g:ConqueTerm_StartMessages = 0

    command! Sh ConqueTermSplit bash --login
    command! Irb ConqueTermSplit irb
    command! Py ConqueTermSplit ipython
  endif
  " }}}

  " yankring
  " {{{
  if index(g:pathogen_disabled, 'yankring') == -1
    let g:yankring_history_file = '.vim_yankring_history'
    if !has('clipboard')
      let g:yankring_manual_clipboard_check = 0
    endif

    nnoremap <silent> ,y :YRShow<CR>
  endif
  " }}}

  " syntastic
  " {{{
  let g:syntastic_check_on_open = 1
  let g:syntastic_enable_signs = 1
  let g:syntastic_disabled_filetypes = [ 'xhtml' ]
  let g:syntastic_phpcs_disable = 1

  if executable('jshint')
    let g:syntastic_javascript_checker = 'jshint'
  endif

  if !&diff
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_auto_jump = 0
  endif
  " }}}

  " powerline
  " {{{
  if index(g:pathogen_disabled, 'powerline') == -1
    let Powerline_cache_enabled = 1
    if Powerline_cache_enabled == 0
      call system('rm -f ~/.vim/tmp/powerline.*.cache')
    end

    let Powerline_theme = 'desertink'
    let Powerline_colorscheme = 'desertink'

    if has('gui_running')
      let Powerline_cache_file = expand('~/.vim/tmp/powerline.gui.cache')
      let Powerline_symbols = 'fancy'
    else
      let Powerline_cache_file = expand('~/.vim/tmp/powerline.term.cache')
      let Powerline_symbols = 'unicode'
    end
  end
  " }}}

  " netrw
  " {{{
  let g:netrw_silent = 1
  let g:netrw_ftpmode = 'ascii'
  let g:netrw_longlist = 1
  let g:netrw_winsize = 40
  let g:netrw_altv = 1
  let g:DrChipTopLvlMenu = 'Plugins.'
  if has('unix') && exists("$DISPLAY")
    let g:netrw_browsex_viewer = 'xdg-open'
  endif
  " }}}

  " tagbar
  " {{{
  if index(g:pathogen_disabled, 'tagbar') == -1
    let g:tagbar_width = 31
    let g:tagbar_autofocus = 1
    let g:tagbar_sort = 0
    let g:tagbar_compact = 1
    let g:tagbar_expand = 1
    let g:tagbar_singleclick = 1
    let g:tagbar_usearrows = 1

    nnoremap <silent> ,t :TagbarToggle<CR>
  end
  " }}}

  " mini buffer explorer
  " {{{
  let g:miniBufExplSplitBelow = 0
  let g:miniBufExplForceSyntaxEnable = 0
  let g:miniBufExplMapCTabSwitchBufs = 1
  let g:miniBufExplMapWindowNavVim = 1
  let g:miniBufExplMapWindowNavArrows = 1
  let g:miniBufExplMaxSize = 0
  let g:miniBufExplModSelTarget = 1
  let g:miniBufExplTabWrap = 1
  let g:miniBufExplUseSingleClick = 1
  let g:miniBufExplCheckDupeBufs = 0

  autocmd VimEnter,BufRead,BufNewFile * highlight MBEVisibleNormal ctermbg=22 guibg=#265f26
  autocmd VimEnter,BufRead,BufNewFile * highlight MBEVisibleActive cterm=bold ctermbg=28 gui=bold guibg=#368736
  autocmd VimEnter,BufRead,BufNewFile * highlight MBEVisibleChangedActive cterm=bold ctermbg=124 gui=bold guibg=#cc5653
  autocmd VimEnter,BufRead,BufNewFile * highlight MBEVisibleChanged ctermbg=88 guibg=#913d3b
  autocmd VimEnter,BufRead,BufNewFile * highlight MBEChanged ctermbg=88 guibg=#913d3b
  " }}}

  " neocomplcache
  " {{{
  if index(g:pathogen_disabled, 'neocomplcache') == -1
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_enable_auto_select = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_enable_camel_case_completion = 1
    let g:neocomplcache_enable_underbar_completion = 1

    let g:neocomplcache_source_disable = {
      \ 'syntax_complete': 1,
    \ }

    let g:neocomplcache_auto_completion_start_length = 2

    if !exists('g:neocomplcache_omni_patterns')
      let g:neocomplcache_omni_patterns = {}
    endif

    let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
    let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
    let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'

    " Recommended key-mappings.
    " <CR>: cancel popup and save indent.
    inoremap <expr><CR>  neocomplcache#cancel_popup() . "\<CR>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplcache#close_popup()
    inoremap <expr><C-e>  neocomplcache#cancel_popup()

    " use <Tab> to complete words, and also handle snippets
    function! TabWrapper(...)
      if a:0 == 0
        if pumvisible()
          " close the popup and expand snippets
          return "\<C-y>\<C-R>=TabWrapper(1)\<CR>"
        else
          " popup is closed, use normal SnipMate behavior
          return TriggerSnippet()
        endif
      else
        " expand snippets, but don't insert a <Tab>
        return substitute(TriggerSnippet(), '\t', '', '')
      endif
    endfunction
    autocmd VimEnter * inoremap <Tab> <C-R>=TabWrapper()<CR>
  endif
  " }}}

" }}}
