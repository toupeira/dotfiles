" General Settings
" {{{

  set nocompatible
  let $LANG = "en"

  " load all bundles
  runtime bundle/pathogen/autoload/pathogen.vim
  let g:pathogen_disabled = []

  " AutoComplPop requires Vim 7.2
  if v:version < '702'
    call add(g:pathogen_disabled, 'autocomplpop')
  endif

  " FuzzyFinder/L9 require Vim 7.2 and floating-point support
  if v:version < '702' || !has('float')
    call add(g:pathogen_disabled, 'l9')
    call add(g:pathogen_disabled, 'fuzzyfinder')
  endif

  " Gundo requires Vim 7.3 and Python
  if v:version < '703' || !has('python')
    call add(g:pathogen_disabled, 'gundo')
  endif

  call pathogen#infect()

  " file handling
  set nobackup
  set autowrite
  set encoding=utf-8
  set modeline
  set modelines=2
  set undofile
  set undodir=~/.vim/tmp/undo

  " interface
  set hidden
  set lazyredraw
  set splitbelow
  set splitright
  set scrolloff=5
  set virtualedit+=block
  set nostartofline

  " command prompt and status line
  set showcmd
  set ruler
  set laststatus=2
  set history=1000
  set report=0
  set wildmenu
  set wildmode=longest:full,full
  set wildignore=*.pyc,*.o,*.lo,*.la,*.exe,*.swp,*.db,*.bak,*.old,*.dat,*.,tmp,*.mdb,*~,~*

  " searching
  set ignorecase
  set smartcase
  set incsearch
  set hlsearch

" }}}

" Display Settings
" {{{

  if &term == 'screen-bce'
    " enable 256 color support for screen
    set t_Co=256

    " don't clear screen on exit
    "set t_ti=
    "set t_te=
  endif

  " syntax highlighting
  syntax on

  " color scheme
  colorscheme desertink

  " visual bell
  set visualbell
  set errorbells

  " statusline
  autocmd VimEnter,BufRead,BufNewFile * highlight StatusLineGray  cterm=bold ctermfg=231 ctermbg=241 gui=bold guifg=white guibg=#666666
  autocmd VimEnter,BufRead,BufNewFile * highlight StatusLineRed   cterm=bold ctermfg=231 ctermbg=88 gui=bold guifg=white guibg=#913d3b
  autocmd VimEnter,BufRead,BufNewFile * highlight StatusLineGreen cterm=bold ctermfg=231 ctermbg=28 gui=bold guifg=white guibg=#368736

  set statusline=

  set stl+=%#StatusLineGray#\ %n\ %*              " buffer number
  set stl+=%#StatusLineGreen#%{fugitive#statusline()[4:-2]}%* " Git status
  set stl+=%#StatusLineRed#%r%*                   " read-only flag
  set stl+=%#StatusLineRed#%m%*                   " modified flag
  " if $SSH_CONNECTION != ""
  "   set stl+=%{toupper(hostname())}:              " hostname
  " endif
  set stl+=\ %<\"%f\"\                            " file name
  set stl+=%y                                     " file type
  set stl+=[%{strlen(&fenc)?&fenc:&enc}           " file encoding
  set stl+=%{&bomb?',BOM':''}                     " BOM flag
  set stl+=%{&ff!='unix'?','.toupper(&ff):''}]\   " file format
  set stl+=%=                                     " left/right separator
  set stl+=%-20.(%l/%L,%c%)\ %P                   " cursor position

  " line numbers
  set number
  set numberwidth=6

  " cursor line
  "autocmd BufEnter,WinEnter * if bufname('%') != '-MiniBufExplorer-' && &buftype != 'quickfix' | setlocal cursorline | endif
  "autocmd WinLeave * setlocal nocursorline nocursorcolumn

  " highlight trailing whitespace
  autocmd VimEnter,BufRead,BufNewFile * highlight Whitespace ctermbg=236 guibg=#333333
  autocmd VimEnter,BufRead,BufNewFile * match Whitespace /\s\+$/

  " go to last cursor position when opening files
  if has('autocmd')
    autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
                           \| exe "normal g'\"" | endif
  endif

  " window titles
  set title
  if &term == 'screen-bce' || &term == 'rxvt-unicode'
    set t_ts=k
    set t_fs=\
  endif

  if $STY
    set titlestring=%t\ %m
  else
    "set titlestring=%r%m\ %t\ \[%{substitute(expand('%:p:h'),\ $HOME,\ '~',\ 'g')}\]\ -\ %{v:servername}
  endif

" }}}

" Text Formatting
" {{{

  set selection=inclusive
  set backspace=indent,eol,start
  set whichwrap+=<,>,[,],h,l

  " indents
  filetype plugin indent on
  set autoindent
  set smartindent
  set nocindent

  " avoid auto-indenting pound signs
  inoremap # x<C-H>#

  " tabs
  set noexpandtab
  set smarttab
  set shiftround

  " matching
  set showmatch
  runtime macros/matchit.vim
  let b:match_ignorecase = 1

  " diffing
  set diffopt+=iwhite

  " folding
  set foldenable foldmethod=marker
  autocmd Syntax * set foldmethod=marker

" }}}

" Custom Filetype Settings
" {{{

  autocmd FileType alsaconf,applescript,asm,autoit,context,css,dot,eruby,html,io,javascript,lisp,markdown,ocaml,perl,php,puppet,smarty,sql,plaintex,ruby,sh,svn,tex,textile,vb,vim,xhtml,xml,xslt setlocal ts=2 sts=2 sw=2 expandtab nocindent
  autocmd FileType c,cs,cpp,php setlocal ts=3 sts=3 sw=3 expandtab
  autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType apache setlocal ts=4 sts=4 sw=4
  autocmd FileType mail setlocal ts=2 sts=2 sw=2 expandtab tw=80 lbr
  autocmd FileType tex,plaintex,context setlocal lbr
  autocmd FileType gitcommit,gitrebase setlocal colorcolumn=50,72

  autocmd BufEnter /home/*/bin/*.run setf sh
  autocmd BufEnter *.inc,*.thtml setf php
  autocmd BufEnter *.boo setf python
  autocmd BufEnter *.io setf io
  autocmd BufEnter *.red setf textile
  autocmd BufEnter Gemfile,*.plan setf ruby
  autocmd BufEnter ~/.devilspie/* setf lisp
  autocmd BufEnter *.pac setf javascript

  " PHP syntax highlighting
  let php_htmlInStrings = 1
  let php_baselib = 1
  let php_special_functions = 1
  let php_alt_comparisons = 1
  let php_alt_AssignByReference = 1

  let php_folding = 1

  " Ruby block auto-completion
  function! RubyEndToken()
    let current_line = getline( '.' )
    let braces_at_end = '{\s*\(|\(,\|\s\|\w\)*|\s*\)\?$'
    let brackets_at_end = '[\s*\(|\(,\|\s\|\w\)*|\s*\)\?$'
    let stuff_without_do = '^\s*\(class\|if\|unless\|begin\|case\|for\|module\|while\|until\|def\)'
    let with_do = 'do\s*\(|\(,\|\s\|\w\)*|\s*\)\?$'

    if match(current_line, braces_at_end) >= 0
      return "\<CR>}\<C-O>O"
    elseif match(current_line, brackets_at_end) >= 0
      return "\<CR>\1\<C-O>O"
    elseif match(current_line, stuff_without_do) >= 0
      return "\<CR>end\<C-O>O"
    elseif match(current_line, with_do) >= 0
      return "\<CR>end\<C-O>O"
    else
      return "\<CR>"
    endif
  endfunction

  "autocmd FileType ruby inoremap <buffer> <CR> <C-R>=RubyEndToken()<CR>

" }}}

" Keybindings
" {{{

  " command-mode aliases
  cnoreabbrev W w
  cnoreabbrev WQ wq
  cnoreabbrev Q q
  cnoreabbrev QA qa
  cnoreabbrev Qa qa

  " shortcut to edit runtime files
  function! RuntimeFileCompletion(A, L, P)
    let l:dir = getcwd()
    chdir ~/.dotfiles/vim/

    if isdirectory(a:A) && a:A[-1:] != '/'
      let l:arg = a:A.'/'
    else
      let l:arg = a:A
    endif

    let l:values = split(glob(l:arg.'*',), "\n")
    if len(l:values) == 1 && isdirectory(l:values[0])
      let l:values = [ l:values[0].'/' ]
    endif

    execute "chdir ".l:dir
    return l:values
  endfunction
  command! -nargs=1 -complete=customlist,RuntimeFileCompletion E edit ~/.dotfiles/vim/<args>

  " ignore wrapping lines when moving
  noremap j gj
  noremap k gk

  " don't move on *
  nnoremap * *<C-o>

  " map Ctrl+C to Escape
  inoremap <C-c> <Esc>

  " move to matching pair with Tab in visual mode
  vmap <Tab> %

  " toggle paste mode with F12
  set pastetoggle=<f12>

  " emacs keybindings
  cnoremap <C-a> <Home>
  cnoremap <C-e> <End>

  " scroll in insert mode
  inoremap <C-e> <C-o><C-e>
  inoremap <C-y> <C-o><C-y>

  " autocomplete search history in command mode
  cnoremap <C-n> <Up>
  cnoremap <C-p> <Down>

  " ,q / ,e - toggle quickfix window and location list
  function! GetBufferList()
    redir =>buflist
    silent! ls
    redir END
    return buflist
  endfunction

  function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
      if bufwinnr(bufnum) != -1
        exec(a:pfx.'close')
        return
      endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location List is Empty."
        return
    endif
    let winnr = winnr()
    exec(a:pfx.'open')
    if winnr() != winnr
      wincmd p
    endif
  endfunction

  nnoremap <silent> ,q :call ToggleList('Quickfix List', 'c')<CR>
  nnoremap <silent> ,e :call ToggleList('Location List', 'l')<CR>

  " resize quickfix windows to their content, or 20 lines maximum
  function! ResizeWindow(min, max)
    let l:max = min([a:max, &lines / 3])
    execute max([a:min, min([l:max, line('$') + 1])]).'wincmd _'
  endfunction
  autocmd FileType qf call ResizeWindow(2, 20)

  " ,/, F2 - remove highlighted search
  nnoremap <silent> ,/ :noh<CR>
  nnoremap <silent> <F2> :noh<CR>

  " ,1-9 - quick buffer switching
  nnoremap <silent> ,1 :b1<CR>
  nnoremap <silent> ,2 :b2<CR>
  nnoremap <silent> ,3 :b3<CR>
  nnoremap <silent> ,4 :b4<CR>
  nnoremap <silent> ,5 :b5<CR>
  nnoremap <silent> ,6 :b6<CR>
  nnoremap <silent> ,7 :b7<CR>
  nnoremap <silent> ,8 :b8<CR>
  nnoremap <silent> ,9 :b9<CR>

  " ,b - fuzzy find buffers
  nnoremap <silent> ,b :FufBuffer<CR>

  " ,c - close current window
  nnoremap <silent> ,c :silent! close<CR>

  " ,d - open definition in new window
  nmap <silent> ,d <C-w>f

  " ,f - fuzzy find files
  nnoremap <silent> ,f :FufFileWithCurrentBufferDir<CR>

  " ,F - toggle syntax folding
  function! ToggleFolding()
    if &foldcolumn == 0
      if &filetype == 'python'
        setlocal foldmethod=indent
      else
        setlocal foldmethod=syntax
      endif
      setlocal foldcolumn=3
    else
      setlocal foldcolumn=0 foldmethod=marker
    endif
  endfunction

  nnoremap <silent> ,F :call ToggleFolding()<CR>

  " ,g - grep the current file
  function! GrepCurrentFile()
    if expand('%') == ''
      return
    endif

    echohl ModeMsg
    let l:pattern = substitute(input("Grep file: /", expand('<cword>')), '"', '\"', '')

    if l:pattern != ""
      echohl ModeMsg
      echo "/ searching..."
      execute 'silent grep "'.l:pattern.'" %'

      let l:len = len(getqflist())
      if l:len > 0
        copen
        redraw
        echo l:len l:len == 1 ? "match" : "matches" "found"
      else
        echohl ErrorMsg
        echo "Pattern not found in current file: ".l:pattern
      endif
    endif

    echohl None
  endfunction
  nnoremap <silent> ,g :call GrepCurrentFile()<CR>

  " ,G - grep the current path
  function! GrepCurrentPath()
    echohl Question
    let l:pattern = substitute(input("Grep path: /", expand('<cword>')), '"', '\"', '')

    if l:pattern != ""
      if exists('b:rails_root')
        let l:path = b:rails_root.'/{app,config,lib,vendor/plugins,public/javascripts,public/stylesheets}'
      else
        let l:path = '.'
      endif

      echohl Question
      echo "/ searching..."
      execute 'silent grep -r "'.l:pattern.'" '.l:path

      let l:len = len(getqflist())
      if l:len > 0
        copen
        redraw
        echo l:len l:len == 1 ? "match" : "matches" "found"
      else
        echohl ErrorMsg
        echo "Pattern not found in current path: ".l:pattern
      endif
    endif

    echohl None
  endfunction
  nnoremap <silent> ,G :call GrepCurrentPath()<CR>

  " ,i - toggle indent guides
  nnoremap <silent> ,i :IndentGuidesToggle<CR>

  " ,l - fuzzy find lines
  nnoremap <silent> ,l :FufLine<CR>

  " ,n - next buffer
  nnoremap <silent> ,n :bnext<CR>

  " ,N - toggle line numbers
  function! ToggleLineNumbers()
    if &number
      set nonumber
    elseif &relativenumber
      set number
    else
      set relativenumber
    endif
  endfunction
  nnoremap <silent> ,N :call ToggleLineNumbers()<CR>

  " ,p - previous buffer
  nnoremap <silent> ,p :bprevious<CR>

  " ,P - toggle paste
  nnoremap <silent> ,P :set paste!<CR>

  " ,r - reload current buffer
  nnoremap <silent> ,r :edit<CR>

  " ,R - reload vimrc
  nnoremap <silent> ,R :runtime! vimrc gvimrc<CR>:let &ft=&ft<CR>:nohlsearch<CR>

  " ,s - split horizontally
  nnoremap <silent> ,s :split<CR>

  " ,S - show syntax attributes
  nnoremap <silent> ,S :call SyntaxAttr()<CR>

  " ,t - toggle tagbar
  nnoremap <silent> ,t :TagbarToggle<CR>

  " ,u - open gundo
  nnoremap <silent> ,u :GundoToggle<CR>

  " ,v - split vertically
  nnoremap <silent> ,v :vsplit<CR>

  " ,w - write file
  nnoremap <silent> ,w :write<CR>

  " ,W - clear trailing whitespace
  nnoremap <silent> ,W mw:%s/\s\s*$//e<CR>:nohlsearch<CR>`w:echohl Question<CR>:echo "Trailing whitespace cleared"<CR>:echohl none<CR>

  " ,x - toggle NERDTree
  nnoremap <silent> ,x :NERDTreeToggle<CR>

  " ,y - toggle yankring
  nnoremap <silent> ,y :YRShow<CR>

  " F4 / F5 - change window height
  nnoremap <silent> <F4> <C-w>+
  imap <silent> <F4> <C-o><F4>
  nnoremap <silent> <F5> <C-w>-
  imap <silent> <F5> <C-o><F5>

  " F6 / F7 - change window width
  nnoremap <silent> <F6> <C-w>>
  imap <silent> <F6> <C-o><F6>
  nnoremap <silent> <F7> <C-w><
  imap <silent> <F7> <C-o><F7>

  " conque bindings
  command! Sh ConqueTermSplit bash --login
  command! Irb ConqueTermSplit irb
  command! Py ConqueTermSplit ipython

" }}}

" Plugin Settings
" {{{

  runtime ftplugin/man.vim
  runtime scripts/SyntaxAttr.vim

  " netrw
  let g:netrw_silent = 1
  let g:netrw_ftpmode = 'ascii'
  let g:netrw_longlist = 1
  let g:netrw_winsize = 40
  let g:netrw_altv = 1
  let g:DrChipTopLvlMenu = 'Plugins.'
  if has('unix') && exists("$DISPLAY")
    let g:netrw_browsex_viewer = 'gnome-open'
  endif

  " buffer explorer
  let g:miniBufExplSplitBelow = 0
  let g:miniBufExplForceSyntaxEnable = 0
  let g:miniBufExplMapCTabSwitchBufs = 1
  let g:miniBufExplMapWindowNavVim = 1
  let g:miniBufExplMapWindowNavArrows = 1
  let g:miniBufExplMaxSize = 0
  let g:miniBufExplModSelTarget = 1
  let g:miniBufExplTabWrap = 1
  let g:miniBufExplUseSingleClick = 1
  let g:miniBufExplCheckDupeBufs = 0

  autocmd VimEnter,BufRead,BufNewFile * highlight MBEVisibleNormal ctermbg=22 guibg=#265f26
  autocmd VimEnter,BufRead,BufNewFile * highlight MBEVisibleActive cterm=bold ctermbg=28 gui=bold guibg=#368736
  autocmd VimEnter,BufRead,BufNewFile * highlight MBEVisibleChangedActive cterm=bold ctermbg=124 gui=bold guibg=#cc5653
  autocmd VimEnter,BufRead,BufNewFile * highlight MBEVisibleChanged ctermbg=88 guibg=#913d3b
  autocmd VimEnter,BufRead,BufNewFile * highlight MBEChanged ctermbg=88 guibg=#913d3b

  " nerd tree
  let g:NERDChristmasTree = 1
  let g:NERDTreeQuitOnOpen = 1
  let g:NERDTreeDirArrows = 1

  " syntastic
  let g:syntastic_enable_signs = 1
  let g:syntastic_disabled_filetypes = [ 'xhtml' ]

  if !&diff
    let g:syntastic_auto_loc_list = 1
    let g:syntastic_auto_jump = 0
  endif

  " indent guides
  let g:indent_guides_auto_colors = 0
  autocmd VimEnter,BufRead,BufNewFile * highlight IndentGuidesOdd  ctermbg=235 guibg=#2a2a2a
  autocmd VimEnter,BufRead,BufNewFile * highlight IndentGuidesEven ctermbg=236 guibg=#333333

  " closetag
  autocmd BufEnter * runtime scripts/closetag.vim

  " tcomment
  let g:tcomment_types = {'php': {'commentstring_rx': '\%%(//\|#\) %s', 'commentstring': '# %s'}}

  " tagbar
  let g:tagbar_width = 31
  let g:tagbar_autofocus = 1
  let g:tagbar_sort = 0
  let g:tagbar_compact = 1
  let g:tagbar_expand = 1
  let g:tagbar_singleclick = 1
  let g:tagbar_usearrows = 1

  " yankring
  let g:yankring_history_file = '.vim_yankring_history'

  " rails
  hi! link rubyRailsARMethod Statement

  " conque
  let g:ConqueTerm_StartMessages = 0

  " autocomplpop
  "let g:acp_mappingDriven = 1
  let g:acp_completeoptPreview = 1
  let g:acp_behaviorKeywordLength = 3
  let g:acp_behaviorKeywordIgnores = [
    \ 'the', 'def', 'end',
    \ 'else', 'elsif', 'elif', 'endif', 'then',
    \ 'case', 'done',
    \ ]

  " only enable if a filetype is set
  if exists(':AcpEnable')
    let g:acp_enableAtStartup = 0
    autocmd FileType * AcpEnable
  endif

  " use <Tab> to complete words, and also handle snippets
  function! TabWrapper(...)
    if a:0 == 0
      if pumvisible()
        " close the popup and expand snippets
        return "\<CR>\<C-R>=TabWrapper(1)\<CR>"
      else
        " popup is closed, use normal SnipMate behavior
        return TriggerSnippet()
      endif
    else
      " expand snippets, but don't return the <Tab>
      call TriggerSnippet()
      return ''
    endif
  endfunction
  autocmd VimEnter * inoremap <Tab> <C-R>=TabWrapper()<CR>

  " session plugin
  let g:session_directory="~/.vim/tmp/sessions"
  cnoreabbrev SS SaveSession
  cnoreabbrev OS OpenSession
  cnoreabbrev CS CloseSession
  cnoreabbrev DS DeleteSession
  cnoreabbrev VS ViewSession

  cnoreabbrev QS SaveSession \| quitall

  " indent object
  autocmd VimEnter * omap <silent>ai aI
  autocmd VimEnter * vmap <silent>ai aI

" }}}
