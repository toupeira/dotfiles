" Initialisation
" {{{

  set nocompatible
  set encoding=utf-8
  scriptencoding utf-8

  let s:vimdir = expand("~") . "/.vim"

  " disable defaults.vim
  let g:skip_defaults_vim = 1

  " set up pathogen
  runtime bundle/pathogen/autoload/pathogen.vim
  if !exists('g:pathogen_disabled')
    let g:pathogen_disabled = []
  endif

  " disable netrw
  let g:loaded_netrwPlugin = 1

  " only enable tmux plugins in tmux sessions
  if empty($TMUX)
    call add(g:pathogen_disabled, 'tmux-complete')
  endif

  " load bundles
  call pathogen#infect()

  augroup vimrc
    autocmd!
  augroup END

" }}}

" General Settings
" {{{

  " file handling
  filetype plugin indent on
  set hidden
  set nobackup
  set writebackup
  set backupcopy=auto
  set modeline
  set modelines=2
  set updatetime=100

  if v:version > 703 && !has('nvim')
    set cryptmethod=blowfish
  endif

  " searching
  set ignorecase
  set smartcase
  set hlsearch
  set incsearch
  if exists('&inccommand')
    set inccommand=nosplit
  endif

  if executable('rg')
    let &grepprg = "rg --vimgrep"
  endif

  " enable persistent undo
  if has('persistent_undo')
    set undofile
  endif

  " spell checking
  if has('spell')
    set nospell
    set spellfile=~/.vim/spells/en.add

    if !isdirectory(s:vimdir . '/spells')
      call mkdir(s:vimdir . '/spells', 'p')
    endif
  endif

" }}}

" Display Settings
" {{{

  " interface
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  set termguicolors

  syntax on
  colorscheme custom

  " terminals
  if has('nvim')
    autocmd vimrc TermOpen * setlocal nonumber norelativenumber signcolumn=no | startinsert!
    autocmd vimrc BufWinEnter,WinEnter term://* startinsert!
    autocmd vimrc BufWinLeave,WinLeave term://* stopinsert
  endif

  " ambience theme from terminator
  if has('nvim')
    let g:terminal_color_0  = '#555753'
    let g:terminal_color_1  = '#ef2929'
    let g:terminal_color_2  = '#8ae234'
    let g:terminal_color_3  = '#fce94f'
    let g:terminal_color_4  = '#729fcf'
    let g:terminal_color_5  = '#ad7fa8'
    let g:terminal_color_6  = '#34e2e2'
    let g:terminal_color_7  = '#eeeeec'

    let g:terminal_color_8  = '#555753'
    let g:terminal_color_9  = '#ef2929'
    let g:terminal_color_10 = '#8ae234'
    let g:terminal_color_11 = '#fce94f'
    let g:terminal_color_12 = '#729fcf'
    let g:terminal_color_13 = '#ad7fa8'
    let g:terminal_color_14 = '#34e2e2'
    let g:terminal_color_15 = '#eeeeec'
  endif

  set errorbells
  set visualbell t_vb= " disable bells
  set cmdheight=1
  set signcolumn=yes
  set synmaxcol=1000 " disable syntax highlighting on long lines
  set lazyredraw
  if !&diff
    set nocursorline
  endif

  " mouse support
  set mouse=a
  if exists('&ttymouse')
    set ttymouse=xterm2
  endif

  " windows
  set winheight=3
  set winminheight=3
  set splitbelow
  set splitright

  " auto-completion
  set completeopt=menuone,noinsert
  if exists('&pumblend')
    set pumblend=10
  endif

  " line numbers
  set number
  set numberwidth=6
  set norelativenumber

  " scrolling
  set scrolloff=5
  set sidescrolloff=8
  set sidescroll=1
  set virtualedit+=block
  set nostartofline
  set display+=lastline

  if has('conceal')
    set concealcursor=nvc
    set conceallevel=0
  endif

  " command prompt and status line
  set showcmd
  set noshowmode
  set noruler
  set laststatus=2
  set history=1000
  set report=0
  set shortmess+=a
  set wildmenu
  set wildignore=*.pyc,*.o,*.lo,*.la,*.exe,*.swp,*.db,*.bak,*.old,*.dat,*.,tmp,*.mdb,*~,~*

  " automatically open quickfix window after commands that modify the quickfix list
  " autocmd vimrc QuickFixCmdPost *grep* if len(getqflist()) > 1 | copen | elseif len(getqflist()) <= 1 | cclose | endif

  " highlight trailing whitespace
  autocmd vimrc VimEnter,Colorscheme * hi! Whitespace ctermbg=235 guibg=#333333
  autocmd vimrc VimEnter,Colorscheme * match Whitespace /\s\+$/

  " window/icon titles
  set title
  set icon

  if match($TERM, '^\(tmux\|screen\)-') == 0
    let &t_ts = "\033k"
    let &t_fs = "\033\\"

    let &t_IS = "\033]0;"
    let &t_IE = "\007"
  endif

  " show the project name and relative path to the current file
  function! ProjectPath(short) " {{{
    let l:root = substitute(getcwd(), '/\.git$', '', '')

    if !exists('b:git_dir')
      return substitute(l:root, '^' . $HOME, '~', '')
    else
      let l:project = fnamemodify(l:root, ':t')
      let l:path = fnamemodify(expand('%'), ':p:h')

      if a:short || winwidth(0) < 60
        " only return project name
        return l:project
      else
        " return project name with relative path
        let l:path = substitute(l:path, '^\(fugitive://\)\?' . substitute(l:root, '\~', '\\~', 'g') . '/\?', '', '')

        if empty(l:path)
          return l:project
        else
          return l:project . ': ' . l:path
        endif
      endif
    endif
  endfunction " }}}

  let &titlestring = "%t%m%r\ ‚ù∞%{ProjectPath(1)}‚ù±"
  let &iconstring = &titlestring

  " add Unicode marker for tmux navigation
  if !empty($TMUX) || !empty($SUDO_COMMAND)
    let &iconstring .= " %{mode(1) == 'n' || mode() == 't' || &ft == 'fzf' ? 'üòë' : 'üòÆ'}"

    if has('nvim') || !empty($CYGWIN)
      let &titlestring = &iconstring
    endif
  endif

" }}}

" Text Formatting
" {{{

  set formatoptions+=j
  set backspace=indent,eol,start
  set whichwrap+=<,>,[,],h,l
  set iskeyword+=-
  set selection=inclusive
  set nrformats=hex

  " indents
  set autoindent

  " tabs
  set ts=2 sts=2 sw=2
  set expandtab
  set smarttab
  set shiftround

  " matching
  set showmatch

  " diffing
  set diffopt+=algorithm:histogram,indent-heuristic

  " folding
  set foldmethod=indent
  set foldlevel=99999

" }}}

" Filetype Settings
" {{{

  autocmd vimrc FileType c,cs,cpp,php setlocal ts=3 sts=3 sw=3
  autocmd vimrc FileType python,apache,sshconfig setlocal ts=4 sts=4 sw=4
  autocmd vimrc FileType css,scss setlocal iskeyword+=%
  autocmd vimrc FileType make setlocal noexpandtab
  autocmd vimrc FileType text,markdown,mail setlocal linebreak suffixesadd+=.md
  autocmd vimrc FileType tex,plaintex,context setlocal lbr
  autocmd vimrc FileType gitcommit,gitrebase setlocal colorcolumn=50,72
  autocmd vimrc FileType crontab setlocal nobackup nowritebackup
  autocmd vimrc FileType puppet setlocal commentstring=#%s
  autocmd vimrc FileType help setlocal nonumber norelativenumber nospell
  autocmd vimrc FileType help nnoremap <buffer><silent> q :bd<CR>
  autocmd vimrc FileType org setlocal foldmethod=expr
  autocmd vimrc FileType qf setlocal nobuflisted
  autocmd vimrc FileType vim setlocal foldmethod=marker foldlevel=0

  autocmd vimrc BufRead,BufNewFile *.es6 setlocal ft=javascript
  autocmd vimrc BufRead,BufNewFile Dangerfile,*.axlsx,*.prawn setlocal ft=ruby

  " show recent log entries in commit messages
  " start insert mode when committing
  function! s:CommitStartInsert()
    if getline(1) == ''
      normal O
      startinsert
    endif
  endfunction
  autocmd vimrc FileType gitcommit call <SID>CommitStartInsert()

" }}}

" Commands
" {{{

  " edit vimrc
  command! RC edit $MYVIMRC

  " helper to preserve search and cursor position
  command! -nargs=1 Preserve call <SID>Preserve(<args>)
  function! s:Preserve(command) " {{{
    let search=@/
    let line = line('.')
    let column = col('.')
    execute a:command
    let @/ = search
    call cursor(line, column)
  endfunction " }}}

  command! -nargs=1 PreserveSearch call <SID>PreserveSearch(<args>)
  function! s:PreserveSearch(command) " {{{
    let search=@/
    execute a:command
    let @/ = search
  endfunction " }}}

  " Replace a builtin command using cabbrev
  " http://vim.wikia.com/wiki/Replace_a_builtin_command_using_cabbrev
  command! -nargs=+ CommandAlias call <SID>CommandAlias(<f-args>)
  function! s:CommandAlias(abbreviation, expansion) " {{{
    execute 'cabbrev ' . a:abbreviation . ' <c-r>=getcmdpos() == 1 && getcmdtype() == ":" ? "' . a:expansion . '" : "' . a:abbreviation . '"<CR>'
endfunction " }}}

  CommandAlias E e
  CommandAlias E! e!
  CommandAlias Q Q
  CommandAlias Q! Q!
  CommandAlias QA qa
  CommandAlias Qa qa
  CommandAlias qA qa
  CommandAlias QA! qa!
  CommandAlias Qa! qa!
  CommandAlias qA! qa!
  CommandAlias WQ wq
  CommandAlias Wq wq
  CommandAlias wQ wq
  CommandAlias WQ! wq!
  CommandAlias Wq! wq!
  CommandAlias wQ! wq!

  " diff shortcuts for visual mode
  command! Dg diffget
  command! Dp diffput

  " shortcuts to open files externally and perform online searches
  if has('mac')
    let g:open_command = 'open'
  elseif has('unix')
    let g:open_command = 'xdg-open'
  else
    let g:open_command = 'start'
  endif
  command! -nargs=+ -complete=file_in_path Open call system(g:open_command.' ' . expand("<args>"))

  " open markdown preview
  command! -nargs=0 VMD execute 'silent !vmd % &>/dev/null &' | redraw!

" }}}

" Keybindings
" {{{

  noremap H ^
  noremap L $

  " toggle folds with Space
  nnoremap <Space> za

  " apply macros with Q (disables the default Ex mode shortcut)
  nnoremap Q @q
  vnoremap Q :norm @q<CR>

  " shortcut for desktop clipboard
  noremap + "+

  " don't use exact searches for */#
  noremap * g*
  noremap # g#
  noremap g* *
  noremap g# #

  " break undo chain on new lines
  inoremap <CR> <C-g>u<CR>

  " duplicate the selection
  vnoremap D y`]pgv

  " repeat command for each line in selection
  xnoremap . :normal .<CR>

  " shortcuts for diff
  nnoremap du :diffupdate<CR>

  " map Ctrl+C to Escape
  inoremap <C-c> <Esc>
  autocmd vimrc CmdWinEnter * nnoremap <buffer> <C-c> :

  " delete to black hole register with X
  noremap X "_d
  nnoremap XX "_dd

  " keep cursor position when yanking in visual mode
  xnoremap <silent><expr> y "ygv" . mode()

  " reselect visual block after indent
  xnoremap <silent> > >gv
  xnoremap <silent> < <gv

  " select pasted text
  nmap vp `[v`]

  " toggle paste mode with F12
  set pastetoggle=<f12>

  " switch to alternate buffer
  nnoremap <silent><expr> ,<Tab> empty(getreg('#')) \|\| !buflisted(getreg('#')) ? ':bnext<CR>' : '<C-^>'

  " terminal mappings
  tnoremap <Esc> <C-\><C-n>

  " don't open tags with Ctrl-LeftClick
  noremap <C-LeftMouse> <nop>
  noremap! <C-LeftMouse> <nop>

  " navigate windows/tmux panes with Ctrl+jkhl
  function! TmuxNavigate(cmd) " {{{
    let nr = winnr()

    execute('wincmd ' . a:cmd)

    if (empty($TMUX))
      return
    elseif (nr != winnr())
      return
    endif

    let pane = str2nr(system('tmux display -p "#{pane_index}"'))
    let panes = str2nr(system('tmux display -p "#{window_panes}"'))

    if (((a:cmd == 'k' || a:cmd == 'h') && nr == 1 && pane == 1) ||
          \ ((a:cmd == 'j' || a:cmd == 'l') && nr == winnr('$') && pane == panes))
      " silent call system('tmux resize-pane -Z')
    else
      let arg = tr(a:cmd, 'hjkl', 'LDUR')
      silent call system('tmux select-pane -' . arg)
    endif
  endfunction " }}}

  nnoremap <silent> <c-h> :call TmuxNavigate('h')<CR>
  nnoremap <silent> <c-j> :call TmuxNavigate('j')<CR>
  nnoremap <silent> <c-k> :call TmuxNavigate('k')<CR>
  nnoremap <silent> <c-l> :call TmuxNavigate('l')<CR>

  tnoremap <silent> <c-h> <C-\><C-n>:call TmuxNavigate('h')<CR>
  tnoremap <silent> <c-j> <C-\><C-n>:call TmuxNavigate('j')<CR>
  tnoremap <silent> <c-k> <C-\><C-n>:call TmuxNavigate('k')<CR>
  tnoremap <silent> <c-l> <C-\><C-n>:call TmuxNavigate('l')<CR>

  " alias Ctrl-v as Ctrl-q
  noremap <C-q> <C-v>
  inoremap <C-q> <C-v>
  cnoremap <C-q> <C-v>

  " Copy & Paste shortcuts
  if has('mac')
    vnoremap <D-c> "+y
    vnoremap <D-x> "+d

    map <D-v>  "+gP
    cmap <D-v> <C-R>+

    exe 'inoremap <script> <D-v>' paste#paste_cmd['i']
    exe 'vnoremap <script> <D-v>' paste#paste_cmd['v']
  else
    vnoremap <C-c> "+ygv<Esc>
    vnoremap <C-x> "+d<Esc>

    noremap <C-v>  "+gP
    cnoremap <C-v> <C-r>+

    exe 'inoremap <script> <C-v>' paste#paste_cmd['i']
    exe 'vnoremap <script> <C-v>' paste#paste_cmd['v']
  endif

  " ,q and ,e - toggle quickfix window and location list
  nnoremap <silent> ,q :call <SID>ToggleList('c')<CR>
  nnoremap <silent> ,e :call <SID>ToggleList('l')<CR>
  function! s:ToggleList(command) " {{{
    let windows = winnr('$')
    exec(a:command.'close')
    if windows != winnr('$')
      return
    endif

    if a:command == 'c' && !len(getqflist())
      echohl Question
      echo "Quickfix list is empty."
      return
    elseif a:command == 'l' && !len(getloclist(0))
      echohl Question
      echo "Location list is empty."
      return
    endif

    let winnr = winnr()
    exec(a:command.'open')
    if winnr() != winnr
      wincmd p
    endif
  endfunction " }}}

  " resize quickfix windows to their content, or 10 lines maximum
  autocmd vimrc FileType qf,ale-preview call <SID>ResizeWindow(2, 10)
  function! s:ResizeWindow(min, max) " {{{
    nnoremap <buffer><silent> q :bd<CR>
    let max = min([a:max, &lines / 3])
    execute max([a:min, min([max, line('$') + 1])]).'wincmd _'
  endfunction " }}}

  " Ctrl-c - remove highlighted search and redraw
  nnoremap <silent> <C-c> :nohlsearch<CR>:redraw!<CR>

  " <count>` - switch buffers
  nnoremap <silent><expr> ` v:count ? ":<C-u>b<C-r>=v:count<CR><CR>" : "`"

  " <count>~ - delete buffers
  nnoremap <silent><expr> ~ v:count ? ":<C-u>bd<C-r>=v:count<CR><CR>" : "~"

  " ,n / ,p - next/previous buffer
  nnoremap <silent> ,n :bnext<CR>
  nnoremap <silent> ,p :bprevious<CR>

  " ,c - close current window
  nnoremap <silent> ,c :call <SID>CloseWindow()<CR>
  function! s:CloseWindow() " {{{
    if &buftype != 'quickfix'
      let windows = len(filter(
        \ range(1, winnr('$')),
        \ "getbufvar(winbufnr(v:val), '&buftype') != 'quickfix'"
      \ ))

      if windows == 1
        return
      endif
    endif

    close
  endfunction " }}}

  " ,x - close the current buffer, keeping windows
  nnoremap <silent> ,x :silent lclose<CR>:silent Bdelete<CR>

  " ,X - close the current buffer, not keeping windows
  nnoremap <silent> ,X :silent lclose<CR>:silent bd<CR>

  " ,d - open file in new split
  nmap <silent> ,d <C-w>f

  " ,s - split horizontally
  nnoremap <silent> ,s :split<CR>

  " ,v - split vertically
  nnoremap <silent> ,v :vsplit<CR>

  " ,w - write current buffer
  nnoremap <silent> ,w :write<CR>:redraw<CR>

  " ,$ - clear trailing whitespace
  nnoremap <silent> ,$ :call <SID>ClearTrailingWhitespace()<CR>
  function! s:ClearTrailingWhitespace() " {{{
    Preserve 'silent %s/\s\s*$//e'
    echohl Question
    echo "Trailing whitespace cleared"
    echohl none
  endfunction " }}}

  " ,N - toggle line numbers
  nnoremap <silent> ,N :call <SID>ToggleLineNumbers()<CR>
  function! s:ToggleLineNumbers() " {{{
    if &number
      set nonumber norelativenumber
    else
      set number norelativenumber
    endif
  endfunction " }}}

" }}}

" Plugin Settings
" {{{

  " fugitive {{{
  nnoremap <silent> ,gs :G<CR>
  noremap <silent> ,gl :Gclog<CR>
  noremap <silent> ,gL :0Gclog<CR>
  noremap <silent> ,gB :Gblame<CR>
  noremap ,gu :.Gbrowse!<CR>
  noremap ,gU :.Gbrowse<CR>

  autocmd vimrc FileType fugitive if b:fugitive_type == 'index' | setlocal nobuflisted | endif
  autocmd vimrc FileType fugitive nmap <buffer> <silent> q gq
  " }}}

  " dirvish {{{
  autocmd vimrc FileType dirvish nmap <buffer> <silent> q gq
  " }}}

  " markdown {{{
  let g:vim_markdown_conceal = 0
  let g:vim_markdown_folding_disabled = 1
  let g:vim_markdown_frontmatter = 1
  let g:vim_markdown_strikethrough = 1
  " }}}

  " dispatch {{{
  let g:dispatch_no_maps = 1
  let g:dispatch_handlers = [ 'job' ]
  " }}}

  " org-mode {{{
  " silence warning about missing plugin
  command! -nargs=* -range SpeedDatingFormat echo
  " }}}

  " elm {{{
  let g:elm_detailed_complete = 1
  let g:elm_jump_to_error = 0
  " }}}

  " json {{{
  let g:vim_json_syntax_conceal = (&conceallevel > 0)
  let g:vim_json_syntax_concealcursor = &concealcursor
  " }}}

  " devicons {{{
  let g:webdevicons_enable = 0
  let g:webdevicons_enable_airline_tabline = 0
  let g:webdevicons_enable_airline_statusline = 0
  " }}}

  " vista {{{
  nnoremap <silent> ,t :Vista finder<CR>
  nnoremap <silent> ,T :Vista!!<CR>

  let g:vista_sidebar_width = 40
  let g:vista_blink = [1, 100]
  let g:vista_icon_indent = ["‚óè ", "‚ñ∂ "]
  let g:vista_fzf_preview = ['right:hidden:70%']

  let g:vista_default_executive = 'ctags'
  let g:vista_finder_alternative_executives = [ 'ctags' ]

  " let g:vista_executive_for = {
  "   \ 'sh': 'ale',
  "   \ 'javascript': 'ale',
  "   \ 'typescript': 'ale',
  "   \ 'ruby': 'ale'
  " \ }
  " }}}

  " pasta {{{
  let g:pasta_disabled_filetypes = ['qf']
  " }}}

  " reply {{{
  nnoremap <silent> ,! :Repl<CR>
  noremap <silent> ,> :ReplSend<CR>
  noremap <silent> ,< :ReplRecv<CR>

  function! s:reply_bash() abort
    return reply#repl#base('bash', {
      \ 'command_options': ['-l'],
      \ 'prompt_start': '^[^[]\+ \[[^[]\+]\( ‚ù∞.*‚ù±\)\? ',
      \ 'prompt_continue': '^ *¬ª ',
    \ })
  endfunction

  function! s:reply_ruby() abort
    return reply#repl#base('pry', {
      \ 'prompt_start': '^\[\d\+] pry\(\[[^]]\+\]\)\? ¬ª ',
      \ 'prompt_continue': '^ *¬ª ',
    \ })
  endfunction

  let g:reply_repls = {
    \ 'sh': [function('s:reply_bash')],
    \ 'ruby': [function('s:reply_ruby')],
  \ }
  " }}}

  " test {{{
  let g:test#strategy = 'dispatch'

  nnoremap <silent> ,@ :TestFile<CR>
  nnoremap <silent> ,# :TestNearest<CR>
  " }}}

  " ragtag {{{
  let g:ragtag_global_maps = 1

  imap <C-]> <C-x>/
  autocmd vimrc User Ragtag silent! iunmap <buffer> <C-v>%
  autocmd vimrc User Ragtag silent! iunmap <buffer> <C-v>&
  " }}}

  " rooter {{{
  let g:rooter_change_directory_for_non_project_files = 'current'
  let g:rooter_use_lcd = 1
  let g:rooter_silent_chdir = 1
  let g:rooter_patterns = [
    \ 'elm-package.json',
    \ 'ng-package.json',
    \ 'package.json',
    \ 'go.mod',
    \ 'mix.exs',
    \ 'Gemfile',
    \ 'Rakefile',
    \ '.git',
    \ '.git/',
  \ ]
  " }}}

  " tabular {{{
  noremap <silent> ,a :Tabular /
  noremap <silent> ,a{ :Tabular /{<CR>
  noremap <silent> ,a} :Tabular /}<CR>
  noremap <silent> ,a[ :Tabular /[<CR>
  noremap <silent> ,a] :Tabular /]<CR>
  noremap <silent> ,a\| :Tabular /\|<CR>
  noremap <silent> ,a> :Tabular /-><CR>
  noremap <silent> ,a= :Tabular /\(\|\|\)\?=\+>\?<CR>
  noremap <silent> ,a, :Tabular /,\zs/l0r1<CR>
  noremap <silent> ,a: :Tabular /[^:]:\s\zs/l0r1<CR>
  " }}}

  " ale {{{
  if index(g:pathogen_disabled, 'ale') == -1
    nnoremap <silent> ,E :ALEDetail<CR>

    hi! link ALEWarning Whitespace
    hi! clear ALEErrorSign
    hi! clear ALEWarningSign

    hi! ALEVirtualTextError guifg=#ff4040 gui=bold
    hi! ALEVirtualTextWarning guifg=#999999
    hi! link ALEVirtualTextInfo ALEVirtualTextWarning

    let g:ale_sign_error = 'üî•'
    let g:ale_sign_warning = '‚ö†Ô∏è'
    let g:ale_sign_info = 'üíß'

    let g:ale_lint_on_insert_leave = 1
    let g:ale_lint_on_text_changed = 'normal'

    let g:ale_set_balloons = 0
    let g:ale_virtualtext_cursor = 1
    let g:ale_virtualtext_prefix = '‚Üí '

    let g:ale_linters = {
      \ 'ruby': [ 'ruby', 'rubocop' ],
      \ 'javascript': [ 'eslint', 'tsserver' ],
      \ 'typescript': [ 'tslint', 'tsserver' ]
    \ }

    " let g:ale_sh_shellcheck_options = '-e 2086,2155'
  endif
  " }}}

  " deoplete {{{
  if index(g:pathogen_disabled, 'deoplete') == -1
    let g:deoplete#enable_at_startup = 1

    " <Tab> - trigger and accept completion
    inoremap <silent><expr> <Tab>
      \ pumvisible() ? "\<C-y>" :
      \ <SID>check_back_space() ? "\<Tab>" :
      \ deoplete#mappings#manual_complete()

    function! s:check_back_space() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~ '\s'
    endfunction

    " <CR> - reject completion and close popup
    inoremap <CR> <C-r>=(pumvisible() ? "<C-e>" : "")<CR><C-g>u<CR>
  endif
  " }}}

  " airline {{{
  if index(g:pathogen_disabled, 'airline') == -1
    let g:airline_powerline_fonts = 1
    let g:airline_inactive_collapse = 0
    let g:airline_detect_paste = 0
    let g:airline_detect_iminsert = 0
    let g:airline_detect_spell = 0

    let g:airline_extensions = [ 'ale', 'branch', 'quickfix', 'tabline', 'vista' ]

    let g:airline#extensions#ale#show_line_numbers = 0
    let g:airline#extensions#ale#error_symbol = ''
    let g:airline#extensions#ale#warning_symbol = ''
    let g:airline#extensions#ale#checking_symbol = ''

    let g:airline#extensions#branch#displayed_head_limit = 16
    let g:airline#extensions#branch#format = 2
    let g:airline#extensions#branch#vcs_checks = []

    let g:airline#extensions#tabline#buffers_label = 'ÔÄä'
    let g:airline#extensions#tabline#tabs_label = 'tabs'
    let g:airline#extensions#tabline#overflow_marker = ' ‚Ä¶ '
    let g:airline#extensions#tabline#formatter = 'unique_tail_improved'
    let g:airline#extensions#tabline#buffer_nr_show = 1
    let g:airline#extensions#tabline#buffer_min_count = 2
    let g:airline#extensions#tabline#fnamemod = ':t'
    let g:airline#extensions#tabline#fnamecollapse = 0

    if !exists('g:airline_symbols')
      let g:airline_symbols = {}
    endif

    " add space after readonly symbol
    call airline#init#bootstrap()
    let g:airline_symbols.readonly .= ' '

    let g:airline_mode_map = {
      \ '__' : '#',
      \ 'n'  : 'n',
      \ 'i'  : 'i',
      \ 'ic' : 'i',
      \ 'ix' : 'i',
      \ 'R'  : 'r',
      \ 'v'  : 'v',
      \ 'V'  : 'V',
      \ 'c'  : 'c',
      \ '' : '^v',
      \ 's'  : 's',
      \ 'S'  : 'S',
      \ '' : 's‚Ä¢b',
      \ }

    let g:airline#extensions#default#section_truncate_width = {
      \ 'b': 80
    \ }

    " show file directory separately from file name
    call airline#parts#define_raw('file', '%t%m')
    call airline#parts#define_raw('filepath', '%#airline_filepath#[%<%{ProjectPath(0)}]')
    let g:airline_section_c = airline#section#create(['file', g:airline_symbols.space, 'readonly', 'filepath'])

    " switch filetype and format/encoding, and only show
    " file format and encoding if it's not the default
    let g:airline_section_x = airline#section#create([
      \ "%{&ff == 'unix' ? '' : '  ' . WebDevIconsGetFileFormatSymbol()}%{&fenc == 'utf-8' ? '' : '   ' . &fenc}"
    \ ])
    let g:airline_section_y = airline#section#create(['%{WebDevIconsGetFileTypeSymbol()} %{&ft}'])

    " don't show position percentage
    let g:airline_section_z = airline#section#create(['windowswap', 'linenr', ':%v'])

    hi! airline_filepath          guifg=#697098 guibg=#333747 gui=bold
    hi! airline_filepath_inactive guifg=#697098 guibg=#333747
    hi! airline_vista             guifg=#ffc266 guibg=#333747
  endif
  " }}}

  " fzf {{{
  if index(g:pathogen_disabled, 'fzf') == -1
    let g:fzf_layout = { 'window': 'enew' }
    let g:fzf_action = { 'ctrl-s': 'split', 'ctrl-v': 'vsplit' }

    nnoremap <silent> ,f :Files<CR>
    nnoremap <silent> ,F :Files <C-r>=expand('%:h')<CR>/<CR>
    nnoremap <silent> ,h :History<CR>
    nnoremap <silent> ,b :Buffers<CR>
    nnoremap <silent> ,l :BLines<CR>
    nnoremap <silent> ,L :Lines<CR>

    nnoremap <expr>   ,r ':Rg '.expand('<cword>')
    nnoremap <silent> ,R :Rg<CR>

    nnoremap <silent> ,gb :Branches<CR>
    nnoremap <silent> ,gp :Projects<CR>

    nnoremap <silent> ,: :History:<CR>
    nnoremap <silent> ,/ :History/<CR>
    nnoremap <silent> ,? :Maps<CR>

    " hide statusline in bottom window
    autocmd! vimrc FileType fzf
    autocmd  vimrc FileType fzf echo
      \| execute "if winnr() == winnr('$') | set laststatus=0 | endif"
      \| autocmd vimrc BufLeave <buffer> set laststatus=2

    " add preview to :Files
    command! -bang -nargs=? -complete=dir Files
      \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({}, 'right:70%:hidden'), <bang>0)

    " add preview to :Rg
    command! -bang -nargs=* Rg
      \ call fzf#vim#grep(
      \   'rg --column --line-number --no-heading --color=always '.shellescape(<q-args>), 1,
      \   <bang>0 ? fzf#vim#with_preview('right:70%')
      \           : fzf#vim#with_preview('right:70%:hidden'),
      \   <bang>0)

    " tweak :GFiles
    command! -bang -nargs=? GFiles
      \ call fzf#vim#gitfiles(
      \   <q-args>, { 'options': [
      \     '--ansi', '--multi', '--nth', '2..,..', '--tiebreak=index', '--prompt', 'GitFiles?> ',
      \     '--preview', 'git diff --color=always HEAD -- {-1} | sed 1,4d | grep . || fzf-preview {-1}',
      \     '--preview-window', 'right:70%'
      \   ] })

    " add :Branches command
    function! s:fzf_branches(line)
      let l:parser = split(a:line)
      let l:branch = l:parser[0]
      if l:branch ==? '*'
        let l:branch = l:parser[1]
      endif
      execute '!git checkout ' . l:branch
    endfunction

    command! -bang -nargs=0 Branches
      \ call fzf#vim#grep(
      \   'git branches', 0, {
      \     'sink': function('s:fzf_branches'),
      \     'options': ['--prompt', 'Branches> ']
      \   }, <bang>0)

    " add :Projects command
    function! s:fzf_projects(project)
      exe 'cd ' . trim(system('src --path')) . '/' . a:project
      Files
      call feedkeys('i', 'n')
    endfunction

    command! -bang -nargs=0 Projects
      \ call fzf#vim#grep(
      \   ' src list -a', 0, {
      \     'sink': function('s:fzf_projects'),
      \     'options': ['--prompt', 'Projects> ']
      \    }, <bang>0)
  endif
  " }}}

  " signify {{{
  nnoremap <silent> ,gd :SignifyHunkDiff<CR>

  let g:signify_vcs_list = ['git']

  let g:signify_sign_add               = '+ '
  let g:signify_sign_delete            = '-'
  let g:signify_sign_delete_first_line = '^'
  let g:signify_sign_change            = '¬∑'

  hi! link SignifySignAdd DiffAdd
  hi! link SignifySignChange DiffChange
  hi! link SignifySignDelete DiffDelete
  " }}}

  " didyoumean {{{
  let g:dym_use_fzf = 1
  " }}}

  " sandwich {{{
  runtime macros/sandwich/keymap/surround.vim
  " }}}

  " go {{{
  let g:go_get_update = 0
  let g:go_gopls_enabled = 0
  let g:go_template_autocreate = 0

  let g:go_highlight_extra_types = 1
  let g:go_highlight_operators = 1
  let g:go_highlight_functions = 1
  let g:go_highlight_function_parameters = 1
  let g:go_highlight_function_calls = 1
  let g:go_highlight_types = 1
  let g:go_highlight_fields = 1
  let g:go_highlight_variable_declarations = 1
  let g:go_highlight_variable_assignments = 1
  " }}}

  " matchup {{{
  let g:matchup_matchparen_offscreen = {}
  let g:matchup_matchparen_deferred = 1
  " }}}

  " cycle {{{
  map <C-a> <Plug>CycleNext
  map <C-x> <Plug>CyclePrev
  noremap <Plug>CycleFallbackNext <C-a>
  noremap <Plug>CycleFallbackPrev <C-x>

  let g:cycle_no_mappings = 1

  let g:cycle_default_groups = [
    \ [[ '&&', '||' ]],
    \ [[ '+', '-' ]],
    \ [[ '+=', '-=' ]],
    \ [[ '==', '!=' ]],
    \ [[ '>', '<' ]],
    \ [[ '>=', '<=' ]],
    \ [[ 'above', 'below' ]],
    \ [[ 'active', 'inactive' ]],
    \ [[ 'add', 'remove' ]],
    \ [[ 'and', 'or' ]],
    \ [[ 'asc', 'desc' ]],
    \ [[ 'assert', 'refute' ]],
    \ [[ 'before', 'after' ]],
    \ [[ 'credit', 'debit' ]],
    \ [[ 'debug', 'info', 'warn', 'error', 'fatal' ]],
    \ [[ 'enable', 'disable' ]],
    \ [[ 'even', 'odd' ]],
    \ [[ 'exclude', 'include' ]],
    \ [[ 'first', 'last' ]],
    \ [[ 'get', 'set' ]],
    \ [[ 'height', 'width' ]],
    \ [[ 'horizontal', 'vertical' ]],
    \ [[ 'in', 'out' ]],
    \ [[ 'internal', 'external' ]],
    \ [[ 'left', 'right' ]],
    \ [[ 'max', 'min' ]],
    \ [[ 'next', 'previous' ]],
    \ [[ 'old', 'new' ]],
    \ [[ 'only', 'except' ]],
    \ [[ 'on', 'off' ]],
    \ [[ 'read', 'write' ]],
    \ [[ 'show', 'hide' ]],
    \ [[ 'staging', 'production' ]],
    \ [[ 'to', 'from' ]],
    \ [[ 'top', 'bottom' ]],
    \ [[ 'true', 'false' ]],
    \ [[ 'up', 'down' ]],
    \ [[ 'without', 'with' ]],
    \ [[ 'yes', 'no' ]],
  \ ]

  let g:cycle_default_groups += [
    \ [[ 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday' ]],
    \ [[ 'january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december' ]],
  \ ]

  let g:cycle_default_groups_for_ruby = [
    \ [[ 'class', 'module' ]],
    \ [[ 'else', 'elsif' ]],
    \ [[ 'get', 'post', 'put', 'patch' ]],
    \ [[ 'if', 'unless' ]],
    \ [[ 'present', 'blank' ]],
  \ ]

  let g:cycle_default_groups_for_eruby = g:cycle_default_groups_for_ruby
  let g:cycle_default_groups_for_haml = g:cycle_default_groups_for_ruby
  " }}}

  " startify {{{
  let g:startify_files_number = 5
  let g:startify_update_oldfiles = 1
  let g:startify_bookmarks = [ {'c': '/etc/dotfiles/vim/vimrc'} ]

  let g:startify_lists = [
    \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
    \ { 'type': 'files',     'header': ['   MRU']            },
    \ { 'type': 'sessions',  'header': ['   Sessions']       },
    \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
    \ { 'type': 'commands',  'header': ['   Commands']       },
  \ ]

  if has('nvim')
    let g:startify_ascii = [
      \ "      .            .",
      \ "    .,;'           :,.",
      \ "  .,;;;,,.         ccc;.",
      \ ".;c::::,,,'        ccccc:",
      \ ".::cc::,,,,,.      cccccc.",
      \ ".cccccc;;;;;;'     llllll.",
      \ ".cccccc.,;;;;;;.   llllll.",
      \ ".cccccc  ';;;;;;'  oooooo.",
      \ "'lllllc   .;;;;;;;.oooooo'",
      \ "'lllllc     ,::::::looooo'",
      \ "'llllll      .:::::lloddd'",
      \ ".looool       .;::coooodo.",
      \ "  .cool         'ccoooc.",
      \ "    .co          .:o:.",
      \ "      .           .'",
    \ ]
  else
    let g:startify_ascii = [
      \ "     ________ ++     ________",
      \ "    /VVVVVVVV\++++  /VVVVVVVV\\",
      \ "    \VVVVVVVV/++++++\VVVVVVVV/",
      \ "     |VVVVVV|++++++++/VVVVV/'",
      \ "     |VVVVVV|++++++/VVVVV/'",
      \ "    +|VVVVVV|++++/VVVVV/'+",
      \ "  +++|VVVVVV|++/VVVVV/'+++++",
      \ "+++++|VVVVVV|/VVV___++++++++++",
      \ "  +++|VVVVVVVVVV/##/ +_+_+_+_",
      \ "    +|VVVVVVVVV___ +/#_#,#_#,\\",
      \ "     |VVVVVVV//##/+/#/+/#/'/#/",
      \ "     |VVVVV/'+/#/+/#/+/#/ /#/",
      \ "     |VVV/'++/#/+/#/ /#/ /#/",
      \ "     'V/'  /##//##//##//###/",
      \ "              ++",
    \ ]
  endif

  let g:startify_custom_header = map(g:startify_ascii, '"   ".v:val')
  " }}}

  " multiple-cursors {{{
  let g:multi_cursor_exit_from_visual_mode = 1
  let g:multi_cursor_exit_from_insert_mode = 1
  let g:multi_cursor_quit_key = '<C-c>'
  " }}}

  " smoothie {{{
  let g:smoothie_base_speed = 20
  " }}}

  " ruby {{{
  let g:ruby_operators = 1
  let g:ruby_pseudo_operators = 1
  let g:ruby_no_expensive = 1

  let g:ruby_indent_block_style = 'do'
  let g:ruby_indent_assignment_style = 'variable'

  hi! link rubyRailsARMethod Statement
  " }}}

  " definitive {{{
  nnoremap <silent> gd :call ALEFallback('ALEGoToDefinition', 'FindDefinition')<CR>
  nnoremap <silent> gD :call ALEFallback('ALEGoToDefinitionInSplit', 'SFindDefinition')<CR>

  let g:definitive_associated_filetypes = {}
  " }}}

  " vue {{{
  let g:vue_pre_processors = ['scss']
  " }}}

  " goldenview {{{
  let g:goldenview__enable_default_mapping = 0
  " }}}

  " context {{{
  set maxmempattern=2000
  let g:context_enabled = 0
  let g:context_border_char = '‚îÅ'

  nnoremap <silent> ,C :ContextPeek<CR>
  " }}}

" }}}
