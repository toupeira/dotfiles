#!/bin/bash

PROCFILE=$( find ~/.procfile.d/"$( basename "$PWD" )" Procfile 2>/dev/null | head -1 )

function usage {
  echo "Usage: mux [OPTIONS] [COMMAND..]"
  echo
  echo "Commands:"
  echo "  mux                   Create a new window"
  echo "  mux COMMAND..         Run a command in a new window"
  echo "  mux @PROCESS          Run a process from a Procfile in a new window"
  echo
  echo "  mux store [PATH]      Store the current directory for the pane"
  echo "  mux restore           Restore the current directory for the pane"
  echo "  mux loop COMMAND..    Run a command repeatedly"
  echo "  mux title TITLE       Set the current tmux window title"
  echo
  echo "Options:"
  echo "  -t TITLE      Specify title for new window"
  echo "  -s            Split window horizontally"
  echo "  -v            Split window vertically"
  echo "  -b            Small pane on the bottom"
  echo "  -r            Small pane on the right"
  echo "  -w            Wait after command exits"
  echo
  echo "Pass options to tmux:"
  echo "  -d, -c PATH, -l SIZE, -p PERCENTAGE"
  echo

  exit 255
}

case "$1" in
  # Run a process from a Procfile
  @*)
    proc="${1:1}"
    shift

    if [ -f "$PROCFILE" ]; then
      commands=$( grep -Eo "^$proc.*:.+" "$PROCFILE" )
      count=$( echo "$commands" | grep -c . )

      if [ $count -gt 0 ]; then
        echo "$commands" | while read -r command; do
          localproc=$( echo "$command" | cut -d: -f1 )
          command=$( echo "$command" | cut -d: -f2- )
          title=${localproc:${#proc}+1}
          title=${title:-$localproc}

          case "$localproc" in
            watcher)
              options="-d -r"
              ;;
            *)
              options="-d"
              ;;
          esac

          $0 -t "@$title" $options "$@" "$0 loop '$command'"
        done

        exit
      fi
    fi

    command="$proc $*"
    options="-b"

    # Or run a predefined command
    case "$proc" in
      bundle)
        [ -f Gemfile ] && mux -b -d -w bundle
        [ -f package.json ] && mux -b -d -w yarn

        exit 0
        ;;
      console)
        if [ -x bin/rails ]; then
          command="rails console"
        elif [ -x bin/middleman ]; then
          command="middleman console"
        elif [ -f elm-package.json ]; then
          command="elm-repl"
        elif [ -f Gruntfile.js ]; then
          command="node"
        elif [ -x bin/console ]; then
          command="bin/console"
        else
          echo "Can't find console for project."
          exit 1
        fi
        ;;
      log)
        if [ -f "log/development.log" ]; then
          command="tail -n 0 -f log/development.log"
        else
          echo "Can't find log for project."
          exit 1
        fi
        ;;
      migrate)
        if [ -f Gemfile ] && [ -d db/migrate ]; then
          mux -b -d -w "bundle exec rake db:migrate; [ -f db/schema.rb ] && git checkout db/schema.rb; [ -f db/structure.sql ] && git checkout db/structure.sql"
        else
          echo "Can't find migrations for project."
          exit 1
        fi

        exit 0
        ;;
      server)
        options="-d"

        if [ -f GDK_ROOT ] || [ -f ../GDK_ROOT ]; then
          gdk start
          command="gdk tail"
        elif [ -x bin/rails ] || [ -x script/rails ]; then
          command="rails server"
        elif [ -x bin/middleman ]; then
          command="middleman server"
        elif [ -f mix.exs ] && grep -q :phoenix mix.exs; then
          command="mix phoenix.server"
        elif [ -f elm-package.json ]; then
          command="elm live Main.elm"
        elif [ -f package.json ] && jq -e .scripts.serve package.json >/dev/null; then
          command="yarn -s serve --open"
        elif [ -f .ember-cli ]; then
          command="ember serve"
        elif [ -f Gruntfile.js ] || [ -f Gruntfile.coffee ]; then
          command="grunt serve"
        elif [ -x bin/server ]; then
          command="bin/server"
        else
          echo "Can't find server for project."
          exit 1
        fi
        ;;
      watcher)
        options="-d"

        if [ -f Guardfile ]; then
          command="bundle exec guard"
        elif [ -f elm-package.json ]; then
          command="elm live Main.elm"
        elif [ -f angular.json ] || [ -f .angular-cli.json ]; then
          command="ng test"
          [ -f yarn.lock ] && command="yarn exec -s -- $command"
        elif [ -f Gruntfile.js ] || [ -f Gruntfile.coffee ]; then
          command="grunt watch"
        else
          echo "Can't find watcher for project."
          exit 1
        fi
        ;;
      *)
        echo "Unknown process '$proc'"
        exit 1
        ;;
    esac

    $0 -t "@$proc [$( basename "$PWD" )]" $options "$@" "$0 loop $command"
    ;;

  # Store/restore the current directory for the pane
  store|restore)
    if [ -n "$TMUX_PANE" ]; then
      pane=$( echo "$TMUX_PANE" | tr -d % )
    else
      pane=$( tmux display -p '#D' | tr -d % )
    fi

    if [ "$1" = "store" ]; then
      tmux setenv "TMUXPWD_$pane" "${2:-$PWD}"
    else
      path=$( tmux showenv "TMUXPWD_$pane" 2>/dev/null | cut -d= -f2- )
      [ -n "$path" ] && cd "$path" && echo "$path"
    fi
    ;;

  # Run a process repeatedly
  loop)
    shift
    command=( "$@" )

    while true; do
      clear
      trap 'kill -9 %1' INT
      (eval "${command[@]}")
      wait
      trap - INT

      >&2 echo -ne "
 \\e[0;34m[\\e[1;34m ${command[*]} \\e[0;34m]•••\\e[0m
   \\e[0;36m• \\e[1;36mR\\e[0;36mestart command\\e[0m
   \\e[0;36m• \\e[1;36mE\\e[0;36mxecute another command\\e[0m
   \\e[0;33m• \\e[1;33mQ\\e[0;33muit\\e[0m
 \\e[0;32m•••\\e[0m "

      read -rn 1 2>/dev/null || exit
      echo

      case "$REPLY" in
        [rR]*|"")
          continue
          ;;
        [eE]*)
          echo -ne "  \\e[0;34m•• \\e[1;34mcommand:\\e[0m "
          read -r
          command=( "$REPLY" )
          ;;
        *)
          echo
          exit
          ;;
      esac
    done
    ;;

  # Set the current tmux window title
  title)
    [ $# -eq 2 ] || usage
    title="$2"

    if [[ "$TERM" =~ ^(tmux|screen) ]]; then
      echo -ne "\e]0;$title\ek$title\e" >&2
    else
      echo -ne "\e]1;$title\\007\e]2;$title\\007" >&2
    fi
    ;;

  # Create a new window
  *)
    action="new-window"
    unset args title wait

    while [ "${1:0:1}" = "-" ]; do
      case "$1" in
        -t)
          title="$2"
          shift
          ;;
        -b)
          action="split-window"
          height=$( tmux list-panes -F '#{pane_active} #{pane_height}' | awk '/^1/ { print $2 }' )
          height=$(( height / 3 ))
          height=$(( height < 10 ? 10 : height ))
          args="$args -v -l $height"
          ;;
        -r)
          action="split-window"
          width=$( tmux list-panes -F '#{pane_active} #{pane_width}' | awk '/^1/ { print $2 }' )
          width=$(( width * 5 / 14 ))
          width=$(( width < 30 ? 30 : width ))
          args="$args -h -l $width"
          ;;
        -s)
          action="split-window"
          args="$args -v"
          ;;
        -v)
          action="split-window"
          args="$args -h"
          ;;
        -d)
          args="$args $1"
          ;;
        -c|-l|-p)
          args="$args $1 $2"
          shift
          ;;
        -w)
          wait=1
          ;;
        *)
          usage
          ;;
      esac

      shift
    done

    if [ $# -eq 0 ]; then
      set --
      set -- bash --login
    elif [ -z "$title" ]; then
      title="$* [$( basename "$PWD" )]"
    fi

    cd "$( $0 restore )" || true

    if [ "$wait" ]; then
      wait="echo -ne '\n\e[0;32m[\e[1;37mDone: \e[1;32m$*\e[0;32m]\e[0m '; read -n 1"
    fi

    tmux $action $args -- "
      export PATH=\"$PATH\";
      $0 title '$title';
      cd \"$PWD\";
      $0 store;
      $*;
      $wait
    " || tmux display "Pane too small"
    ;;
esac
