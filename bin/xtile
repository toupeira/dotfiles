#!/usr/bin/ruby

require 'fileutils'
require 'optparse'
require 'socket'
require 'yaml'

%w[ xwininfo xprop xwit ].each do |command|
  unless system("which #{command} &>/dev/null")
    puts "Sorry, can't find the '#{command}' command."
    exit 1
  end
end

def debug(*args); end

def run
  opts = OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename $0} [OPTIONS] MODE"

    opts.separator ""
    opts.separator "Tiling Modes:"

    modes = "  "
    Xtile::TILING_MODES.keys.map(&:to_s).sort.each_with_index do |mode, i|
      if i > 0 and i % 4 == 0
        opts.separator modes
        modes = "  "
      end
      modes << "#{mode}, "
    end
    opts.separator modes

    opts.separator ""
    opts.separator "Options:"

    opts.on('-v', '--verbose', "Show debug information") do
      def debug(context, *message)
        message = message.map do |m|
          m.is_a?(String) ? m : m.inspect
        end

        puts "#{File.basename $0}[#{$$}]: #{context}: #{message.join ' '}"
      end
    end

    opts.on('-h', '--help', "Show this message") do
      puts opts
      exit
    end

    opts.separator ""
  end

  opts.parse!

  if ARGV[0]
    Xtile.tile ARGV[0]
  else
    puts opts
    exit
  end
end

class Xtile
  Screen = {}

  TILING_MODES = {
    :maximize => lambda {},

    :left => lambda {
      return :width => Screen[:width] / 2 - 8
    },

    :right => lambda {
      return :width  => Screen[:width] / 2,
             :x      => Screen[:x] + Screen[:width] / 2
    },

    :top => lambda {
      return :height => Screen[:height] / 2
    },

    :bottom => lambda {
      return :height => Screen[:height] / 2,
             :y      => Screen[:y] + Screen[:height] / 2
    },

    :center => lambda {
      return :width  => (Screen[:width] * 2 / 3.0).round,
             :height => Screen[:height] - 2 * Screen[:y],
             :x      => Screen[:width] / 2 - (Screen[:width] * 2 / 3.0).round / 2,
             :y      => Screen[:y] * 2
    },

    :topleft => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14
    },

    :topright => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :x      => Screen[:x] + Screen[:width] / 2
    },

    :bottomleft => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :y      => Screen[:y] + Screen[:height] / 2
    },

    :bottomright => lambda {
      return :width  => Screen[:width] / 2,
             :height => Screen[:height] / 2 - 14,
             :x      => Screen[:x] + Screen[:width] / 2,
             :y      => Screen[:y] + Screen[:height] / 2 + 14
    },
  }

  WINDOWS = {}
  CONFIG = "#{ENV['HOME']}/.xtile.conf"
  SOCKET = "#{ENV['HOME']}/.xtile.sock"

  def self.tile(message)
    client.send message, 0
  end

  def self.running?
    File.exists? SOCKET
  end

  def self.start_server
    return false if running?

    if fork
      sleep 0.1
      return true
    end

    Screen.merge! screen_config

    at_exit { stop_server }

    begin
      debug :daemon, "opening server socket..."
      socket = UNIXServer.open(SOCKET)

      while client = socket.accept
        mode = client.recvfrom(100).first.strip.to_sym
        perform_tile mode
      end
    ensure
      stop_server
    end
  end

  def self.stop_server
    if File.exists? SOCKET
      debug :daemon, "removing socket..."
      FileUtils.rm_f SOCKET
    end
  end

private

  def self.window_id
    `xprop -root _NET_ACTIVE_WINDOW`.strip.sub(/.*(0x\w+),.*/, '\1')
  end

  def self.window_size(id)
    if id == :root
      id = '-root'
    else
      id = "-id #{id}"
    end

    data = `xwininfo #{id} | awk '/Absolute upper-left X:|Absolute upper-left Y:/ { print $4 } /Width:|Height:/ { print $2 }'`.split("\n").map(&:to_i)

    return :x      => data[0],
           :y      => data[1],
           :width  => data[2],
           :height => data[3]
  end

  def self.client
    @client ||= UNIXSocket.open(SOCKET)
  rescue Errno::ENOENT, Errno::ECONNREFUSED
    stop_server
    start_server
    retry
  end

  def self.screen_config
    if File.exists? CONFIG
      debug :daemon, "reading screen configuration from #{CONFIG}..."
      config = YAML.load_file CONFIG
      config.is_a?(Hash) ? config : nil
    else
      debug :daemon, "using default screen configuration"
      screen = window_size(:root)
      return :width  => screen[:width],
             :height => screen[:height],
             :x      => 0,
             :y      => 0
    end
  end

  def self.perform_tile(mode)
    id = window_id

    if !options = TILING_MODES[mode]
      debug "window #{id}", "invalid tiling mode #{mode.inspect}"
      return false
    end

    current_options = window_size(id)
    options = Screen.merge(options.call || {})

    window = (WINDOWS[id] ||= {})

    # Check if the mode has changed
    same_mode = window[:mode] == mode

    # Check if the window is already in its new target position
    same_position = !current_options.detect do |key, value|
      (value - options[key].to_i).abs > 50
    end

    # Check if the window was moved from its last target position
    window_moved = !window[:options] || current_options.detect do |key, value|
      (value - window[:options][key].to_i).abs > 50
    end

    # Check if the normal position of the window has changed
    position_changed = !window[:last] || (same_mode && current_options.detect do |key, value|
      (value - window[:last][key].to_i).abs > 50
    end)

    if same_mode and same_position and window[:last]
      mode = :restoring
      options = window[:options] = window[:last]
    elsif window_moved or position_changed
      debug "window #{id}", :storing, current_options
      window[:last] = current_options
    end

    debug "window #{id}", mode, options

    window[:mode] = mode
    window[:options] = options

    system("xwit -id #{id} -move #{options[:x]} #{options[:y]} -resize #{options[:width]} #{options[:height]}")
    system("xwit -id #{id} -sync -focus -warp #{options[:width] / 2} #{options[:height] / 2}")
  end
end

run
