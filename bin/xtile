#!/usr/bin/ruby

require 'fileutils'

class Xtile
  S = {
    :width  => 1850,
    :height => 1065,
    :x      => 40,
    :y      => 40,
  }

  TILING_MODES = {
    :maximize => {},

    :left => {
      :width  => S[:width] / 2 - 8,
    },

    :right => {
      :width  => S[:width] / 2,
      :x      => S[:x] + S[:width] / 2,
    },

    :top => {
      :height => S[:height] / 2,
    },

    :bottom => {
      :height => S[:height] / 2,
      :y      => S[:y] + S[:height] / 2,
    },

    :center => {
      :width  => (S[:width] * 2 / 3.0).round,
      :height => S[:height] - 2 * S[:y],
      :x      => S[:width] / 2 - (S[:width] * 2 / 3.0).round / 2,
      :y      => S[:y] * 2,
    },

    :topleft => {
      :width  => S[:width] / 2,
      :height => S[:height] / 2 - 14,
    },

    :topright => {
      :width  => S[:width] / 2,
      :height => S[:height] / 2 - 14,
      :x      => S[:x] + S[:width] / 2,
    },

    :bottomleft => {
      :width  => S[:width] / 2,
      :height => S[:height] / 2 - 14,
      :y      => S[:y] + S[:height] / 2,
    },

    :bottomright => {
      :width  => S[:width] / 2,
      :height => S[:height] / 2 - 14,
      :x      => S[:x] + S[:width] / 2,
      :y      => S[:y] + S[:height] / 2 + 14,
    },
  }

  WINDOWS = {}
  CONTROL = "#{ENV['HOME']}/.xtile.control"

  def self.tile(message)
    run unless running?
    pipe.puts message
  end

  def self.running?
    File.exists? CONTROL
  end

  def self.run
    if fork
      sleep 0.2
      return true
    end

    at_exit { FileUtils.rm_f CONTROL }

    while mode = pipe.gets.strip
      perform_tile mode
    end
  end

  def self.window_id
    `xprop -root _NET_ACTIVE_WINDOW`.strip.sub(/.*(0x\w+),.*/, '\1')
  end

  def self.window_size(id)
    data = `xwininfo -id #{id} | awk '/Absolute upper-left X:|Absolute upper-left Y:/ { print $4 } /Width:|Height:/ { print $2 }'`.split("\n").map(&:to_i)

    { :x => data[0], :y => data[1],
      :width => data[2], :height => data[3] }
  end

  def self.perform_tile(mode)
    unless options = TILING_MODES[mode.to_sym]
      puts "Invalid tiling mode '#{mode}'"
      return false
    end

    options = S.merge(options)
    id = window_id
    current_options = window_size(id)

    unless window = WINDOWS[id]
      window = WINDOWS[id] = {}
    end

    # Check if the mode has changed
    same_mode = window[:state] == mode

    # Check if the window is already in it's target position
    same_position = !current_options.detect do |key, value|
      (value - options[key].to_i).abs > 50
    end

    # Check if the window was moved from its previous target position
    position_changed = !window[:previous] || (same_mode && current_options.detect do |key, value|
      (value - window[:previous][key].to_i).abs > 50
    end)

    if same_mode and same_position and window[:previous]
      options = window[:options] = window[:previous]
    else
      window[:state] = mode
      window[:options] = options

      if position_changed
        window[:previous] = current_options
      end
    end

    system("xwit -id #{id} -move #{options[:x]} #{options[:y]} -resize #{options[:width]} #{options[:height]}")
    system("xwit -id #{id} -sync -focus -warp #{options[:width] / 2} #{options[:height] / 2}")
  end

  private
    def self.pipe
      unless @pipe
        `mkfifo "#{CONTROL}"` unless File.exists? CONTROL
        @pipe = open(CONTROL, 'r+')
      end

      @pipe
    end
end

Xtile.tile ARGV[0] || 'maximize'
