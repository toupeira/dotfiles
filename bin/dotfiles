#!/bin/bash
# vim: foldmethod=marker foldlevel=0

DOTFILES="/slack/dotfiles"

### usage {{{

function usage {
  echo "Usage: $( basename "$0" ) [options] COMMAND [args]"
  echo
  echo "Options:"
  echo "  -v, --verbose               Increase verbosity"
  echo "  -d, --debug                 Output debug information"
  echo "      --path                  Show path to the dotfiles repository and exit"
  echo
  echo "Commands:"
  echo "  init                        Initialize symlinks, packages, dconf settings"
  echo "  link PATH...                Create symlink for PATH"
  echo "  add PATH...                 Add file to repository and replace it with a symlink"
  echo
  echo "  sync                        Commit, pull, and push changes"
  echo "  commit, ci                  Commit staged changes with default message"
  echo "  commit-all, ca              Commit all changes"
  echo "  pull, up                    Pull remote changes"
  echo "  push, pu                    Push local changes"
  echo
  echo "  rules KEY...                Output rules for given keys"
  echo "  lint [fix]                  Report (and fix) configuration problems"
  echo "  test                        Run tests"
  echo
  echo "  packages, pkg               Install packages"
  echo "  pkg LIST[:TYPE]             Install packages from list"
  echo "  update-packages, pup [TYPE] Update packages"
  echo "  list [NAME]                 List lazy plugins"
  echo
  echo "  dconf sync                  Load dconf settings if no local changes are found"
  echo "  dconf load [KEY]            Load dconf settings"
  echo "  dconf dump [KEY]            Dump dconf settings"
  echo
  echo "Other arguments:"
  echo "  COMMAND [ARGS]...           Excecute a Git command inside the dotfiles repository"
  echo

  exit 255
}

### }}}

### output helpers {{{

# Output a message with a colored symbol in front
function msg {
  local message=${1/$HOME/\~}
  local color=${2:-4}
  local symbol=${3:-●}

  if [ $# -gt 3 ]; then
    shift 3
    local echo_options=( "$@" )
  fi

  if [ -n "$message" ]; then
    echo -e "${echo_options[@]}" " \e[0;3${color}m$symbol\e[0m $message\e[0m" \
      | sed -re 's/\{\{/\o033[1m/g' \
             -e 's/\}\}/\o033[22m/g'
  else
    echo -e "${echo_options[@]}"
  fi
}

# Helpers for colored messages
function status  {
  local message=$(echo "$1" \
    | sed -re 's/\{\{/\o033[1;32m/g' \
           -e 's/\}\}/\o033[1;37m/g' )
  msg "{{$message}}" 2;
}
function info    { msg "\e[0;34m$1" 4; }
function warning { msg "\e[0;33m$1" 3 >&2; }
function error   { msg "\e[0;33m$1" 1 >&2; STATUS=1; }

# Output error message and exit
function abort {
  [ -n "$1" ] && error "$@"
  exit 1
}

# Ask a yes/no question, defaulting to no
function ask {
  msg "$1 \e[0;36m[y/\e[1;36mN\e[0;36m] " "${2:-6}" "»" -n >&2
  read -r
  [ "${REPLY:0:1}" = "Y" ] || [ "${REPLY:0:1}" = "y" ]
}

# Ask a yes/no question, defaulting to yes
function ask-yes {
  msg "$1 \e[0;36m[\e[1;36mY\e[0;36m/n] " "${2:-6}" "»" -n >&2
  read -r
  [ "${REPLY:0:1}" != "N" ] && [ "${REPLY:0:1}" != "n" ]
}

# Ask to continue or abort
function ask-abort {
  [ -n "$1" ] && error "$@"
  if ! ask "{{Do you want to continue?}}" 1; then
    abort
  fi
}

# Output verbose message
function verbose {
  [ "$VERBOSE" = 1 ] && info "$@"
}

# Output debug message
function debug {
  [ "$DEBUG" = 1 ] || return

  echo -e "\e[0;35m$( printf '%10s' "$1" ): │ \e[1m$2\e[0m" >&2
}

# Output indentation
function indent {
  local count=${1:-2}
  for (( i = 0; i < count; i++ )) do
    printf ' '
  done
}

### }}}
### command helpers {{{

# Run a shell command
function system {
  local sudo
  local command="$1"
  shift

  # Check for commands that require sudo
  if [ "$command" = "chown" ] || [ "$command" = "chgrp" ]; then
    sudo="sudo "
  # Check for paths that require sudo
  elif [[ ${!#} =~ ^/(etc|root)/ ]] && ! [[ ${!#} =~ ^$DOTFILES/ ]]; then
    sudo="sudo "
  elif [ "$command" = "mv" ] && [[ $1 =~ ^/(etc|root)/ ]]; then
    sudo="sudo "
  fi

  debug exec "$sudo$command $*"

  command $sudo "$command" "$@" || ask-abort "{{Error:}} $sudo$command $*"
}

# Run a Git command
function git {
  if [ "$1" = "ignore-errors" ]; then
    local onerror=":"
    shift
  fi

  debug exec "git $*"

  (cd "$DOTFILES" && command git "$@")

  local status=$?
  if [ $status -ne 0 ]; then
    STATUS=$status
    $onerror ask-abort "{{Error:}} git $*"
  fi

  return $status
}

# Check for local Git changes
function has-changes {
  git status -s "$@" | grep -q .
}

# Check for remote Git changes
function has-news {
  git diff --stat ORIG_HEAD.. "$@" | grep -q .
}

# Run a command in a tmux pane if possible
function mux-wrap {
  if [ -n "$TMUX" ]; then
    system mux -s -d "$@"
  else
    system "$@"
  fi
}

### }}}
### dotfiles helpers {{{

# Check if machine has a GUI
function has-gui {
  [ "$CHASSIS_TYPE" ] || CHASSIS_TYPE=$( hostnamectl chassis )
  [ "$CHASSIS_TYPE" = "desktop" ] || [ "$CHASSIS_TYPE" = "laptop" ]
}

# Load rules for the given keys
function read-rules {
  if ! [[ $* = *.* ]]; then
    if [ "$1" != "role" ]; then
      local roles=$( read-rules role )
      [ "$roles" ] && roles=$( printf '|role\.%s' $roles )
    fi
    local prefix="(global|host\.$HOSTNAME$roles)\."
  fi

  local pattern=$( printf '|%s' "$@" )
  pattern="^$prefix(${pattern:1})$"

  command git config -f "$DOTFILES/rules.ini" \
    --get-regexp "$pattern" | cut -d\  -f2
}

# Check if a path can be linked or added to the repository
function validate {
  if ! [[ "$1" =~ ^($HOME|/etc)($|/) ]]; then
    error "Path is not inside {{\$HOME}} or {{/etc}}: {{$1}}"
    return 1
  fi

  if ! [ "$SKIP_PATHS" ]; then
    function read-paths {
      mapfile -t paths < <( read-rules "$@" | sed -r 's/\./\\./g' )
      if [ ${#paths[@]} ]; then
        paths=$( printf '|%s($|/)' "${paths[@]}" )
        echo "^(${paths:1})"
      else
        echo "^$"
      fi
    }

    SKIP_PATHS=$( read-paths skip )
    HOST_PATHS=$( read-paths link )
    LINK_PATHS=$( read-paths ".*\.link" )
  fi

  local target=$( target "$1" )
  target=${target:${#DOTFILES}+1}

  if [[ $target =~ $SKIP_PATHS ]] || \
   { [[ $target =~ $LINK_PATHS ]] && ! [[ $target =~ $HOST_PATHS ]]; }; then
    debug skipping "$target"
    return 1
  fi

  return 0
}

# Transform a filesystem path into a repository path
function target {
  local origin="$1"

  if [[ "$origin" =~ ^$HOME/ ]]; then
    local target="${1:${#HOME}+1}"
  elif [[ "$origin" =~ ^/etc/ ]]; then
    local target="${1:1}"
  else
    local target="$origin"
  fi

  echo "$DOTFILES/${target#.}"
}

# Transform a repository path into a filesystem path
function origin {
  local target="$1"
  local topdir="${target%%/*}"

  if [ "$topdir" = "etc" ]; then
    echo "/$target"
  elif [ -e "$HOME/$topdir" ]; then
    echo "$HOME/$target"
  else
    echo "$HOME/.$target"
  fi
}

### }}}

function run {
  debug run "$*"

  local command="$1"
  shift

  case "$command" in
    init) # {{{
      local repository=$( git config remote.origin.url | sed 's|.*github.com[:/]||' )
      git remote set-url --no-push origin "https://github.com/$repository"
      git remote set-url --push    origin "git@github.com:$repository"

      local hook="$DOTFILES/.git/hooks/pre-commit"
      echo -e "#!/bin/sh\nbin/dotfiles test" > "$hook"
      chmod +x "$hook"

      run link-dotfiles "$@"
      run link-slack
      run packages
      has-gui && run dconf sync
      ;;
    # }}}
    link-dotfiles) # {{{
      if [ $# -eq 0 ]; then
        status "Linking {{dotfiles}}..."
        set -- $( fdfind . "$DOTFILES" --exact-depth 1 )
      fi

      for path in "$@"; do
        path=$( echo "${path%/}" | sed -r "s,^$DOTFILES/,," )

        if [ ! -e "$path" ] || ! validate "$( origin "$path" )"; then
          continue
        elif [ -f "$path" ] || [ -L "$path" ] || [ -e "$path/.link" ] || [ -e "$path/.git" ]; then
          run link "$path"
        elif [ -d "$path" ]; then
          run link-dotfiles "$path"/*
        else
          abort "Unknown filetype: $path"
        fi
      done
      ;;
    # }}}
    link-slack) # {{{
      status "Linking {{slack}}..."
      for dir in /slack/*; do
        local name=$( basename "$dir" )
        if [ -d "$dir" ] && ! [[ "$name" =~ ^(backups|dotfiles|lost\+found|scrapbook|virtualbox)$ ]]; then
          run link "$dir" ~/"$name"
        fi
      done

      run link /slack/documents/Notes ~/notes

      for dir in /slack/scrapbook/src/upstream/*; do
        local name=$( basename "$dir" )
        run link "$dir" ~/src/upstream/"$name"
      done
      ;;
    # }}}
    link) # {{{
      [ $# -eq 0 ] && usage

      local path="$1"

      if [ "$2" ]; then
        local origin="$2"
        local target="$1"
      else
        local origin=$( realpath -s -- "${path%/}" )
        local target=$( target "$origin" )
      fi

      local force=0

      if [[ "$origin" =~ ^$DOTFILES/ ]]; then
        target="$origin"
        origin=$( origin "${target:${#DOTFILES}+1}" )
      fi

      if [ -L "$target" ]; then
        target=$( readlink -f "$target" )
      fi

      if [ ! -e "$target" ]; then
        error "Path not found: {{$target}}"
        return
      elif ! validate "$origin"; then
        return
      fi

      if [ -L "$origin" ]; then
        local link=$( readlink "$origin" 2>/dev/null )
        if [ ! -e "$link" ] || [[ $link =~ ^/etc/dotfiles/ ]]; then
          warning "Broken symlink: {{$origin}} -> \e[1;36m$link"
          force=1
        elif [ "$link" = "$target" ]; then
          verbose "Already symlinked: {{$origin}}"
          return
        else
          warning "Symlinked to different path: {{$origin}} -> \e[1;36m$link"
        fi
      fi

      if [ -e "$origin" ] || [ -L "$origin" ]; then
        local ask="ask"
        local question="Delete {{$origin}} and create symlink?"
        local color=3
      else
        local ask="ask-yes"
        local question="Link {{$origin}}?"
      fi

      if [ $force -eq 1 ] || $ask "$question" "$color"; then
        if [ -e "$origin" ] || [ -L "$origin" ]; then
          system rm -r "$origin"
        fi

        local parent=$( dirname "$origin" )
        if [ ! -d "$parent" ]; then
          system mkdir -p "$parent"
        fi

        if [ ! -e "$origin" ] && system ln -s "$target" "$origin"; then
          info "Successfully linked {{$origin}}"
        else
          error "Error while linking {{$origin}}"
          return
        fi
      fi
      ;;
    # }}}
    add) # {{{
      [ $# -eq 0 ] && usage

      for path in "$@"; do
        local origin=$( readlink -f "$path" 2>/dev/null )
        local target=$( target "$origin" )
        local target_dir=$( dirname "$target" )

        if [ ! -e "$origin" ]; then
          abort "Path not found: {{$origin}}"
        elif ! validate "$origin"; then
          continue
        elif [ -L "$path" ]; then
          info "Already symlinked: {{$path}}"
          continue
        fi

        ask-yes "Add {{$origin}} to repository?" || continue

        if (test -d "$target_dir" || system mkdir -p "$target_dir") \
          && system mv "$origin" "$target" \
          && system ln -s "$target" "$origin"
        then
          [ -O "$target" ] || system chown "$USER:${GROUPS[0]}" "$target"
          [ -d "$target" ] && system chmod g+s "$target"
          git add "$target"

          info "Successfully added {{$target}}"
        else
          error "Error while adding path: {{$origin}}"
          continue
        fi
      done
      ;;
    # }}}

    sync) # {{{
      if has-changes; then
        echo
        status "Found local changes:"
        git status -s
        echo
        if ask "{{Commit?}}"; then
          run commit-all
        else
          abort
        fi
      fi

      run pull

      if git status | grep -Fq "Your branch is ahead"; then
        run push
      fi
      ;;
    # }}}
    commit|ci) # {{{
      local staged=$( git staged )
      if ! [ "$staged" ]; then
        warning "{{Nothing to commit.}}"
        return 1
      fi

      echo
      status "Committing changes:"
      echo "$staged" | sed -r 's/^/ \o033[0;32mM\o033[0m /'
      echo

      local args=( "$@" )
      local message="Sync dotfiles"

      if [ "$1" = "-m" ]; then
        message="$2"
        shift 2
      else
        message="Sync dotfiles"
        msg "{{Message:}} \e[0;34m[default] " 4 "" -n
        read -r
        if [ "$REPLY" ]; then
          message="$REPLY"
        fi
      fi

      if [ "$message" ]; then
        args=( "${args[@]}" -m "$message" )
      fi

      git ignore-errors commit "${args[@]}"
      ;;
    # }}}
    commit-all|ca) # {{{
      if ! has-changes; then
        warning "No changes."
        return 1
      fi

      git ignore-errors add -A .
      run commit "$@"
      ;;
    # }}}
    pull|up) # {{{
      status "Fetching changes..."
      git ignore-errors pull -q || abort

      if has-news; then
        git --no-pager diff --stat ORIG_HEAD
      fi

      if has-news packages; then
        run packages
      fi

      if has-news dconf && has-gui; then
        echo
        run dconf sync
      fi
      ;;
    # }}}
    push|pu) # {{{
      status "Pushing changes..."
      git push -q "$@"
      ;;
    # }}}

    rules) # {{{
      read-rules "$@"
      ;;
    # }}}
    lint) # {{{
      status "Running linters..."

      [ "$1" = "fix" ] && local fix=1 && shift
      [ $# -eq 0 ] || usage

      local paths count
      local total=$( grep -c '^ *lint .* ".*"$' "$0" )

      function lint { info "[{{$(( ++count ))/$total}}] $( printf '%8s' "$1" ): {{$2}}"; }
      function list { indent 3; warning "{{$1}}"; }
      function fix  { [ "$fix" ] && indent 6 && "$@"; }

      lint dotfiles "Empty directories"
      for path in $( fdfind . "$DOTFILES" --type d --type e ); do
        list "$path"
        fix system rmdir -v "$path"
      done

      lint home+etc "Orphaned symlinks"
      paths=$(
        sudo fdfind . ~ /root /etc --type l -u \
          --follow \
          --mount \
          --exclude dotfiles \
          --exclude /.local/share/flatpak/repo --exclude /.var/app \
          --exclude src --exclude tmp
      )

      for path in $paths; do
        if [ "$(basename "$path")" = "lock" ]; then
          # --exclude lock doesn't work: https://github.com/sharkdp/fd/issues/746
          continue
        fi

        list "$path"
        fix system rm -v "$path"
      done

      lint home "Incorrect owners"
      for path in $( fdfind . ~ -o root --mount ); do
        list "$path"
        fix system chown "$USER:$USER" -v "$path"
      done

      lint etc "Incorrect permissions"

      local sudoers="$DOTFILES/etc/sudoers.d/dotfiles"
      if [ "$( stat -c %U:%G "$sudoers" )" != "root:root" ]; then
        list "$sudoers"
        fix system chown -v root:root "$sudoers"
      fi

      if [ -d /etc/plymouth ]; then
        local plymouth="/etc/plymouth/plymouthd.conf"
        if diff "$plymouth" "$DOTFILES/$plymouth" | grep -q .; then
          list "$plymouth"
          fix system cp "$DOTFILES$plymouth" "$plymouth"
        fi
      fi

      lint etc "Configuration file clutter"
      for path in $( sudo fdfind '.*\.(dpkg|ucf)-.*' /etc --type f -u ); do
        list "$path"
        fix system rm -v "$path"
      done

      lint root "Skeleton files"
      for path in $( sudo fdfind '^(\.bashrc|\.profile)$' /root --type f -u ); do
        list "$path"
        fix system rm -v "$path"
      done

      lint root "Dotfile symlinks"
      for path in config/mise config/nvim config/rg local/share/mise; do
        local target=$( origin "$path" )
        local origin=${target/#$HOME/\/root}

        [ "$( sudo readlink "$origin" )" = "$target" ] && continue

        list "$origin"
        fix sudo ln -snfv "$target" "$origin"
      done

      lint slack "Syncthing conflicts"
      for path in $( fdfind '\.sync-conflict-.*' /slack/*/.stversions 2>/dev/null ); do
        list "$path"
        fix system rm -v "$path"
      done
      ;;
    # }}}
    test) # {{{
      status "Running tests..."
      local output status

      function fail {
        if [ $status -ne 0 ] || [ "$output" ]; then
          [ "$output" ] && echo "$output"
          error "$1"
        fi
      }

      output=$( "$DOTFILES/bin/dotfiles" --path 2>&1 )
      status=$?
      [ "$output" = "$DOTFILES" ] && output=
      fail "{{bin/dotfiles}} is broken!"

      output=$( fdfind . "$DOTFILES" -t l -x readlink -f {} | grep ^/home/ )
      status=0
      fail "Symlinks to {{/home}} found!"

      output=$( sh -c ". $DOTFILES/etc/profile" 2>&1 )
      status=$?
      fail "{{etc/profile}} is broken with {{sh}}!"

      output=$( bash -ic "" 2>&1 )
      status=$?
      fail "{{etc/profile}} is broken with {{bash}}!"
      ;;
    # }}}

    packages|pkg) # {{{
      # Reinstall/update installed packages
      if [ "$1" = "-f" ]; then
        local force=1
        shift
      fi

      # Install all lists if no list name is given
      if [ $# -eq 0 ] || [ "${1:0:1}" = ":" ]; then
        for list in $( read-rules packages ); do
          run packages "$list$1"
        done
        return
      else
        local list="$1"
      fi

      if [[ "$list" = *:* ]]; then
        local filter="^${list##*:}:"
        local list="${list%%:*}"
      else
        local filter="."
      fi

      local path="$DOTFILES/packages/$list"
      if [ ! -f "$path" ]; then
        abort "Can't find list {{$path}}"
      fi

      # Read packages from list
      local packages=$( grep -E "$filter" "$path" )

      if has-gui && [ -f "$path-gui" ]; then
        packages=$( echo "$packages"; grep -E "$filter" "$path-gui" )
      fi

      if [ -n "$packages" ]; then
        status "Installing {{$list}} packages..."
      fi

      function get-packages { echo "$packages" | grep -E "$1" | sed 's/.*: //' | sort; }

      local packages_apt=$(  get-packages "^[^:#]+$" )
      local packages_gem=$(  get-packages '^gem:' )
      local packages_flat=$( get-packages '^flatpak:' )

      # Find installed packages, cache them in global variables
      [ "$packages_apt" ]  && [ ! "$INSTALLED_APT" ]  && INSTALLED_APT=$(  dpkg --get-selections | cut -f1 | cut -d: -f1 )
      [ "$packages_gem" ]  && [ ! "$INSTALLED_GEM" ]  && INSTALLED_GEM=$(  gem list --no-versions )
      [ "$packages_flat" ] && [ ! "$INSTALLED_FLAT" ] && INSTALLED_FLAT=$( flatpak list --columns=application | tail -n +1 )

      # Find the missing packages for this list
      function get-missing {
        if [ "$force" ]; then
          echo "$1" | sort
        elif [ "$1" ]; then
          comm -23 <( echo "$1" ) <( echo "$2" | sort );
        fi
      }

      [ -n "$packages_apt" ]  && local missing_apt=$(  get-missing "$packages_apt"  "$INSTALLED_APT" )
      [ -n "$packages_gem" ]  && local missing_gem=$(  get-missing "$packages_gem"  "$INSTALLED_GEM" )
      [ -n "$packages_flat" ] && local missing_flat=$( get-missing "$packages_flat" "$INSTALLED_FLAT" )
      [ "$name" = "default" ] && local missing_mise=$( mise ls --missing --no-header | awk '{ print $1 }' )

      if [ -z "$missing_apt"  ] &&
         [ -z "$missing_gem"  ] && \
         [ -z "$missing_flat" ] && \
         [ -z "$missing_mise" ]; then
        return
      fi

      function list-packages {
        [ -n "$2" ] || return
        for package in $2; do
          indent 2
          info "[$1] {{$package}}"
        done
      }

      list-packages apt     "$missing_apt"
      list-packages gem     "$missing_gem"
      list-packages flatpak "$missing_flat"
      list-packages mise    "$missing_mise"

      # Install the packages
      if [ "$force" ] || (echo; ask-yes "{{Install?}}"); then
        function install-packages {
          [ -n "$1" ] || return
          mapfile -t packages <<< "$1"
          shift

          mux-wrap -w "$@" "${packages[@]}"
          system tmux select-layout even-vertical
        }

        install-packages "$missing_apt"  sudo aptitude install
        install-packages "$missing_gem"  gem install
        install-packages "$missing_flat" flatpak install
        install-packages "$missing_mise" mise install
      fi
      echo
      ;;
    # }}}
    update-packages|pup) # {{{
      local filter="$1"

      function update {
        local type="$1"
        local command="$( basename "$0" ) update-$type"
        shift

        if [ -n "$filter" ] && [ "$filter" != "$type" ]; then
          return
        elif [ "$filter" = "$type" ] || ask-yes "Update {{$type}} packages?"; then
          mux-wrap -w "$command"
          system tmux select-layout even-vertical
        fi
      }

      update apt
      update flatpak
      update firmware
      update mise
      update gems
      ;;

    update-apt)      sudo aptitude update && sudo aptitude upgrade;;
    update-flatpak)  flatpak update && flatpak uninstall --unused;;
    update-firmware) fwupdmgr update;;
    update-mise)     mise plugins update && mise upgrade --interactive --bump && mise prune;;
    update-gems)     gem update --system; run packages -f :gem;;
    # }}}

    list) # {{{
      find "$DOTFILES/packages/lazy" -mindepth 1 -maxdepth 1 -type d -printf '%P\n' | sort | fzf -f "$1"
      ;;
    # }}}

    dconf) # {{{
      local action="$1"
      shift

      if [ "$action" = "sync" ]; then
        run dconf dump >/dev/null

        if has-changes dconf; then
          echo
          warning "{{Found local dconf changes:}}"
          git status -s dconf
          echo
          mux-wrap git diff dconf

          ask "{{Ignore and load committed settings?}}" || abort
          git checkout dconf
        fi

        status "Loading {{dconf}} settings..."
        run dconf load >/dev/null
        exit
      fi

      if [ -n "$1" ]; then
        local paths=( "$@" )
      else
        local paths=( "$DOTFILES"/dconf/*.ini )
      fi

      for path in "${paths[@]}"; do
        if [ -f "$path" ] || [ "$path" != "${path%.ini}" ]; then
          local path=$( basename "$path" )
        fi

        local name=${path%.ini}
        local name=${name#/}
        local name=${name%/}
        local name=${name//\//.}

        local file="$DOTFILES/dconf/$name.ini"
        local path="/${name//./\/}/"

        if [ "$action" = "load" ]; then
          info "Loading {{$name}}"
          system dconf load "$path" < "$file"
        elif [ "$action" = "dump" ]; then
          info "Dumping {{$name}}"
          local output=$( system dconf dump "$path" )

          if [ -f "$file" ]; then
            local skip_markers=$( grep -E '^#( skip:.*)?$' "$file" )
            local skip_keys=$( echo "$skip_markers" | sed -rn 's/^# skip: +(.*)/\1/p' )
            local skip_sections=$( echo "$skip_markers" | sed -rn 's/^# skip:section +(.*)/\1/p' )

            (echo "$skip_markers"; echo "$output") \
              | sed -r 's/^\[(.*)\]$/[root "\1"]/' \
              > "$file"

            for key in $skip_keys; do
              [[ $key == *.* ]] && key="root.$key" || key="root./.$key"
              command git config -f "$file" --unset "$key"
            done

            for pattern in $skip_sections; do
              local sections=$( command git config -f "$file" --get-regexp --name-only "^root\.$pattern\." | cut -d. -f1-2 | uniq )
              for section in $sections; do
                command git config -f "$file" --remove-section "$section"
              done
            done

            sed -ri '/^$/d' "$file"
            sed -ri 's/^\[root "(.*)"\]$/\n[\1]/' "$file"
            sed -ri '1{/^$/d}' "$file"
          else
            echo "$output" > "$file"
          fi
        else
          usage
        fi
      done
      ;;
    # }}}

    vim|v)  git edit config/nvim/init.vim;;
    git|g)  git edit config/git/config;;
    tmux|t) git edit config/tmux/tmux.conf;;

    *)
      git ignore-errors "$command" "$@"
      ;;
    # }}}
  esac
}

### main {{{

if [ ! -f "$DOTFILES/bin/dotfiles" ]; then
  abort "Can't find dotfiles script in repository, please check your \$DOTFILES"
fi

COMMAND=
STATUS=

# Parse arguments
while [ $# -gt 0 ]; do
  case "$1" in
    -v|--verbose) VERBOSE=1;;
    -d|--debug)   DEBUG=1;;
       --path)    exec echo "$DOTFILES";;
    -*|help)      usage;;
    *)
      COMMAND=( "$@" )
      break
      ;;
  esac
  shift
done

if [ "${#COMMAND[@]}" ]; then
  run "${COMMAND[@]}"
  exit ${STATUS:$?}
else
  usage
fi

### }}}
