#!/bin/bash
# vim: foldmethod=marker foldlevel=0

### usage {{{

function usage {
  echo "Usage: $( basename "$0" ) [options] COMMAND [args]"
  echo
  echo "Options:"
  echo "  -v, --verbose             Increase verbosity"
  echo "      --path                Show path to the dotfiles repository and exit"
  echo
  echo "Commands:"
  echo "  init                      Install symlinks for all dotfiles interactively"
  echo "  install PATH...           Install symlink for PATH"
  echo "  add PATH...               Add file to repository and replace it with a symlink"
  echo "  lint [fix]                Report or fix configuration problems"
  echo
  echo "  sync                      Commit, pull, and push changes"
  echo "  commit-all, ca            Commit all changes"
  echo "  pull, up                  Pull remote changes and checkout submodules"
  echo "  push                      Push local changes"
  echo
  echo "  list [NAME]               List submodules"
  echo "  update [NAME]             Update submodule"
  echo "  update-all, sup [NAME]    Update all submodules"
  echo
  echo "  build PATH COMMAND..      Run build command in path"
  echo "  build-all                 Run default builds"
  echo
  echo "  package, pkg [:TYPE]      Install default packages"
  echo "  pkg LIST[:TYPE]           Install packages from list"
  echo "  pkg up, pkg TYPE          Update packages"
  echo
  echo "  dconf sync                Load dconf settings if no local changes are found"
  echo "  dconf load [KEY]          Load dconf settings"
  echo "  dconf dump [KEY]          Dump dconf settings"
  echo
  echo "Other arguments:"
  echo "  COMMAND [ARGS]...         Excecute a Git command inside the dotfiles repository"
  echo "  git COMMAND [ARGS]..."
  echo

  exit 255
}

### }}}

### output helpers {{{

# Output a message with a colored arrow in front
function msg {
  local message="${1/$HOME/\~}"
  local color=${2:-4}

  if [ $# -gt 2 ]; then
    shift 2
    local echo_options=( "$@" )
  fi

  if [ -n "$message" ]; then
    echo -e "${echo_options[@]}" " \e[1;3${color}m>\e[0m $message" | sed -r 's/\{\{/\o033[1m/g' | sed -r 's/\}\}/\o033[0m/g'
  else
    echo -e "${echo_options[@]}"
  fi
}

# Helpers for colored messages
function status  { msg "$1" "${2:-2}"; }
function warning { msg "$1" "${2:-3}"; }

# Output verbose message
function verbose {
  [ "$VERBOSE" = 1 ] || return

  echo -e "\e[0;35m$( printf '%10s' "$1" ): â”‚ \e[1;35m$2\e[0m" >&2
}

# Output error message
function error {
  STATUS=1
  msg "$1" 1
}

# Output error message and exit
function abort {
  STATUS=1
  [ -n "$1" ] && error "$@"
  exit 1
}

# Ask a yes/no question, defaulting to no
function ask {
  msg "$1 [y/N] " "${2:-6}" -n >&2
  read -r
  [ "${REPLY:0:1}" = "Y" ] || [ "${REPLY:0:1}" = "y" ]
}

# Ask a yes/no question, defaulting to yes
function ask-yes {
  msg "$1 [Y/n] " "${2:-6}" -n >&2
  read -r
  [ "${REPLY:0:1}" != "N" ] && [ "${REPLY:0:1}" != "n" ]
}

# Ask to continue or abort
function ask-abort {
  if ! ask "{{Do you want to continue?}}" 1; then
    abort
  fi
}

### }}}
### command helpers {{{

# Run a shell command
function system {
  local sudo
  local command="$1"
  shift

  # Check for commands that require sudo
  if [ "$command" = "chown" ] || [ "$command" = "chgrp" ]; then
    sudo="sudo"
  else
    # Check for paths that require sudo
    for arg in "$@"; do
      local dir=$( dirname -- "$arg" )
      if [ "$dir" != "." ] && [ -d "$dir" ] && [ ! -w "$dir" ]; then
        sudo="sudo"
        break
      fi
    done
  fi

  verbose exec "$command $*"

  command $sudo "$command" "$@"
}

# Run a Git command
function git {
  if [ "$1" = "ignore-errors" ]; then
    local onerror=":"
    shift
  else
    local onerror="ask-abort"
  fi

  verbose exec "git $*"

  # Spawn a subshell so we can run the command inside the repository
  # without any nasty side-effects
  ( cd "$DOTFILES" || abort; command git "$@" )
  local status=$?
  [ $status -eq 0 ] || $onerror

  return $status
}

# Check for Git changes
function has-changes {
  git diff --stat ORIG_HEAD "$@" | grep -q .
}

# Run a command in a tmux pane if possible
function mux-wrap {
  if [ -n "$TMUX" ]; then
    system mux -s -d "$@"
  else
    system "$@"
  fi
}

# Escape a regex
function escape-regex {
  echo "${1//\//\\/}"
}

### }}}
### dotfiles helpers {{{

# Make sure the given path is either inside the home directory,
# or a valid /etc path
function validate {
  if ! [[ "$1" =~ ^($HOME|/etc)($|/) ]]; then
    error "Path is not inside \$HOME or /etc: {{$1}}"
    return 1
  else
    return 0
  fi
}

# Transform a filesystem path into a repository path
function target {
  local origin="$1"

  if [[ "$origin" =~ ^$HOME/ ]]; then
    local target="${1:${#HOME}+1}"
  elif [[ "$origin" =~ ^/etc/ ]]; then
    local target="${1:1}"
  else
    local target="$origin"
  fi

  echo "$DOTFILES/${target#.}"
}

# Transform a repository path into a filesystem path
function origin {
  local target="${1:${#DOTFILES}+1}"
  local topdir="${target%%/*}"

  if [ "$topdir" = "etc" ]; then
    echo "/$target"
  elif [ -e "$HOME/$topdir" ]; then
    echo "$HOME/$target"
  else
    echo "$HOME/.$target"
  fi
}

### }}}

function run {
  verbose run "$*"

  local command="$1"
  shift

  case "$command" in
    init) # {{{
      local repository=$( git config remote.origin.url | sed 's|.*github.com[:/]||' )
      git remote set-url --no-push origin "https://github.com/$repository"
      git remote set-url --push    origin "git@github.com:$repository"

      function install-paths {
        for path in "$@"; do
          path=${path%/}

          if [ ! -e "$path" ] || [ "$( basename "$path" )" = "README.md" ]; then
            continue
          fi

          if [ -f "$path" ] || [ -L "$path" ] || [ -e "$path/.install" ]; then
            run install "$path"
          elif [ -e "$path/.skip" ] || [ -e "$path/.git" ]; then
            continue
          elif [ -d "$path" ]; then
            install-paths "$path"/*
          else
            abort "Unknown filetype: $path"
          fi
        done
      }

      if [ $# -gt 0 ]; then
        install-paths "$@"
      else
        install-paths "$DOTFILES"/*
        run package
        run dconf sync
      fi
      ;;
    # }}}
    install) # {{{
      [ $# -eq 0 ] && usage

      for path in "$@"; do
        local path=${path%/}
        local origin="$path"
        local target=$( target "$origin" )
        local force=0

        if [ "${origin:0:1}" != "/" ]; then
          origin="$PWD/$path"
        fi

        if [[ "$origin" =~ ^$DOTFILES/ ]]; then
          target="$origin"
          origin=$( origin "$target" )
        fi

        if [ -L "$target" ]; then
          target=$( readlink -f "$target" )
        fi

        if [ ! -e "$target" ]; then
          error "Path not found: {{$target}}"
          continue
        elif ! validate "$origin"; then
          continue
        fi

        if [ -L "$origin" ]; then
          local link=$( readlink "$origin" 2>/dev/null )
          if [ ! -e "$link" ]; then
            error "Broken symlink: {{$origin}} -> [1;36m$link[0m"
            force=1
          elif [ "$link" = "$target" ]; then
            continue
          else
            warning "Symlinked to different path: {{$origin}} -> [1;36m$link[0m"
          fi
        fi

        if [ -e "$origin" ] || [ -L "$origin" ]; then
          local ask="ask"
          local question="Delete {{$origin}} and install symlink?"
          local color=3
        else
          local ask="ask-yes"
          local question="Install {{$origin}}?"
        fi

        if [ $force -eq 1 ] || $ask "$question" "$color"; then
          if [ -e "$origin" ]; then
            system rm -r "$origin"
          fi

          local parent=$( dirname "$origin" )
          if [ ! -d "$parent" ]; then
            system mkdir -p "$parent"
          fi

          if [ ! -e "$origin" ] && system ln -s "$target" "$origin"; then
            status "Successfully installed {{$origin}}"
          else
            error "Error while installing {{$origin}}"
            continue
          fi
        fi
      done
      ;;
    # }}}
    add) # {{{
      [ $# -eq 0 ] && usage

      for path in "$@"; do
        local origin=$( readlink -f "$path" 2>/dev/null )
        local target=$( target "$origin" )
        local target_dir=$( dirname "$target" )

        if [ ! -e "$origin" ]; then
          abort "Path not found: {{$origin}}"
        elif ! validate "$origin"; then
          continue
        elif [ -L "$path" ]; then
          msg "Already symlinked: {{$path}}"
          continue
        elif [ -e "$target" ]; then
          run install "$target" "$origin"
          continue
        fi

        ask-yes "Add {{$origin}} to repository?" || continue

        if ( test -d "$target_dir" || system mkdir -p "$target_dir" ) \
          && system mv "$origin" "$target" \
          && system ln -s "$target" "$origin"
        then
          system rm -f "$target_dir/.skip"
          [ -O "$target" ] || system chown "$USER:${GROUPS[0]}" "$target"
          [ -d "$target" ] && system chmod g+s "$target"
          git add "$target"

          status "Successfully added {{$target}}"
          (( added++ ))
        else
          error "Error while converting path: {{$origin}}"
          continue
        fi
      done
      ;;
    # }}}
    lint) # {{{
      if [ "$1" = "fix" ]; then
        local delete=( --threads=1 --exec rm -vi {} )
      else
        local delete
      fi

      echo
      warning "{{Broken symlinks}}"
      system sudo fdfind . ~ /root /etc --unrestricted --follow --mount --type symlink \
        --exclude /.local/share/flatpak --exclude /.var/app \
        --exclude src --exclude tmp \
        --color always "${delete[@]}" | grep -Ev '[0-9]mlock\b'
        # --exclude lock doesn't work: https://github.com/sharkdp/fd/issues/746
      echo

      warning "{{Configuration updates}}"
      system sudo fdfind '.*\.(dpkg|ucf)-.*' /etc --unrestricted "${delete[@]}"
      echo
      ;;
    # }}}

    sync) # {{{
      if git status -s | grep -q .; then
        echo
        warning "{{Found local changes:}}"
        git status -s
        echo
        if ask "{{Commit?}}"; then
          run commit-all
        else
          abort
        fi
      fi

      run pull

      if git status | grep -Fq "Your branch is ahead"; then
        run push
      fi
      ;;
    # }}}
    commit-all|ca) # {{{
      if [ "$1" = "-m" ]; then
        shift
        local message="$1"
        shift
      else
        local message="Sync dotfiles"
      fi

      status "{{Committing changes...}}"
      git ignore-errors add -A .
      git ignore-errors commit -a -m "$message" "$@"
      ;;
    # }}}
    pull|up) # {{{
      status "{{Fetching changes...}}"
      git ignore-errors pull -q || abort

      if has-changes; then
        git --no-pager diff --stat ORIG_HEAD
      fi

      mapfile -t modules < <( run list )
      if has-changes "${modules[@]}"; then
        echo
        status "{{Updating submodules...}}"
        git checkout-submodules

        run build-all
      fi

      if has-changes dconf; then
        echo
        run dconf sync
      fi
      ;;
    # }}}
    push|pu) # {{{
      status "{{Pushing changes...}}"
      git push -q "$@"
      ;;
    # }}}

    list|list-submodules) # {{{
      awk "/path = .*$( escape-regex "$1" )/ { print \$3 }" "$DOTFILES/.gitmodules" | sort
      ;;
    # }}}
    update|update-submodule) # {{{
      local batch
      [ "$1" = '--batch' ] && local batch=1 && shift

      local submodule="$1"
      shift

      if [ ! -d "$DOTFILES/$submodule" ]; then
        submodule=$( run list "$submodule" | head -1 )
        if [ -z "$submodule" ]; then
          abort "Submodule not found: {{$submodule}}"
        fi
      fi

      cd "$DOTFILES/$submodule" || abort
      [ -e ".git" ] || abort "Not a git repository: .git"

      local old_commit=$( system git rev-parse HEAD )
      local git_output=$(
        system git fetch -q origin 2>&1 &&
        system git reset -q --hard origin/HEAD 2>&1
      )
      local new_commit=$( system git rev-parse HEAD )

      if [ -n "$git_output" ]; then
        error "Error while updating {{$submodule}}:"
        echo -e "\e[1;31m$git_output\e[0m" | sed -r 's/^/    /'
        echo
      elif [ "$new_commit" != "$old_commit" ]; then
        local url=$( system git remote -v | grep -Eom1 'https?://[^ ]+' )
        [ -n "$url" ] && url=" [ {{$url}} ]"

        [ ! "$batch" ] && echo
        status "Changes in {{$submodule}}$url:" 6
        system git -c color.ui=always log --oneline --no-merges '@{1}..' \
          | sed -r 's/^/    /'
        echo
      elif [ ! "$batch" ]; then
        status "No changes in {{$submodule}}"
      fi
      ;;
    # }}}
    update-all|sup) # {{{
      if [ -n "$1" ]; then
        local submodules=$( run list "$1" )
      else
        local submodules=$( run list | grep -vx asdf )
      fi

      echo
      status "{{Updating submodules:}}"

      local tmpdir=$( mktemp -d "${TMPDIR:-/tmp}/dotfiles.XXXXXX" )

      echo -ne '     \e[1;36m['

      for submodule in $submodules; do
        while [ "$( jobs -r | wc -l )" -gt 10 ]; do
          sleep 0.1
        done

        (
          run update-submodule --batch "$submodule" > "$tmpdir/${submodule//\//-}" 2>&1
          echo -ne '\e[0;36m='
        ) &

        sleep 0.1
      done

      wait
      echo -e '\e[1;36m]\e[0m'
      echo

      if grep -q . "$tmpdir"/* 2>/dev/null; then
        system cat "$tmpdir"/*
        run build-all
      else
        warning "No updates found."
      fi

      system rm -rf "$tmpdir"
      echo
      ;;
    # }}}

    build) # {{{
      local path="$1"
      local command="$2"
      shift 2

      if [ -z "$path" ] || [ -z "$command" ]; then
        usage
      elif [ ! -d "$DOTFILES/$path" ]; then
        warning "Build path {{$path}} does not exist." 5
        return
      fi

      warning "Building {{$path}}"

      if ! ( cd "$DOTFILES/$path" && system "$command" "$@" ); then
        error "Error while building {{$path}}"
        ask-abort
      fi
      ;;
    # }}}
    build-all) # {{{
      has-changes vim/bundle/fzf && run build fzf ./install --bin
      ;;
    # }}}

    package|pkg) # {{{
      local name=${1:-default}
      local filter_apt='^(apt:)?[^:#]+$'

      if [ "$name" = "update" ] || [ "$name" = "up" ]; then
        shift
        run update-packages "$@"
        return
      elif [[ "$name" =~ ^(apt|asdf|gem|yarn|flatpak|firmware)$ ]]; then
        run update-packages "$name"
        return
      elif [[ "$name" =~ : ]]; then
        local filter="^${name##*:}:"
        local name="${name%%:*}"
        [ "$filter" = "^apt:" ] && filter="$filter_apt"
      else
        local filter="."
      fi

      local list="$DOTFILES/packages/$name"
      if [ ! -f "$list" ]; then
        abort "Can't find list '$list'"
      fi

      local packages=$( grep -E "$filter" "$list" )

      if dpkg -s xorg &>/dev/null; then
        [ -f "$list.desktop" ] && packages=$(
          echo "$packages"; grep -E "$filter" "$list.desktop"
        )
      else
        [ -f "$list.server" ] && packages=$(
          echo "$packages"; grep -E "$filter" "$list.server"
        )
      fi

      function get_packages {
        echo "$packages" | grep -E "$1" | sed 's/.*: //' | sort
      }

      local packages_apt=$( get_packages "$filter_apt" )
      local packages_gem=$( get_packages '^gem:' )
      local packages_yarn=$( get_packages '^yarn:' )
      local packages_pip=$( get_packages '^pip:' )
      local packages_flat=$( get_packages '^flatpak:' )

      function get_missing {
        if [ -n "$1" ]; then
          comm -23 <( echo "$1" ) <( echo "$2" | sort )
        fi
      }

      [ -n "$packages_apt" ] && local missing_apt=$(
        get_missing "$packages_apt" \
        "$( dpkg --get-selections | cut -f1 | cut -d: -f1 )"
      )

      [ -n "$packages_gem" ] && local missing_gem=$(
        get_missing "$packages_gem" \
        "$( gem list | awk '/\(/ { print $1 }' )"
      )

      [ -n "$packages_yarn" ] && local missing_yarn=$(
        get_missing "$packages_yarn" \
        "$( ls ~/.config/yarn/global/node_modules 2>/dev/null)"
      )

      [ -n "$packages_pip" ] && local missing_pip=$(
        get_missing "$packages_pip" \
        "$( python3 -m pip -- freeze --system | cut -d= -f1 )"
      )

      [ -n "$packages_flat" ] && local missing_flat=$(
        get_missing "$packages_flat" \
        "$( flatpak list --columns=application | tail -n +1 )"
      )

      if [ -z "$missing_apt"  ] &&
         [ -z "$missing_gem"  ] && \
         [ -z "$missing_yarn" ] && \
         [ -z "$missing_pip"  ] && \
         [ -z "$missing_flat" ]; then
        return
      fi

      echo
      status "{{Missing $name packages:}}"

      function list_packages {
        [ -n "$2" ] || return
        for package in $2; do
          echo -e "    \\e[0;32m[$1] \\e[1;32m$package\\e[0m"
        done
      }

      list_packages apt     "$missing_apt"
      list_packages gem     "$missing_gem"
      list_packages yarn    "$missing_yarn"
      list_packages pip     "$missing_pip"
      list_packages flatpak "$missing_flat"

      echo
      if ask-yes "{{Install?}}"; then
        function install_packages {
          [ -n "$1" ] || return
          mapfile -t packages <<< "$1"
          shift

          mux-wrap -w "$@" "${packages[@]}"
          system tmux select-layout even-vertical
        }

        install_packages "$missing_apt"  sudo aptitude install
        install_packages "$missing_gem"  gem install
        install_packages "$missing_yarn" yarn global add
        install_packages "$missing_pip"  sudo python3 -m pip install --system --upgrade
        install_packages "$missing_flat" flatpak install
      fi
      echo
      ;;
    # }}}
    update-packages) # {{{
      local filter="$1"

      function update {
        local type="$1"
        shift

        if [ -n "$filter" ] && [ "$filter" != "$type" ]; then
          return
        elif [ "$filter" = "$type" ] || ask-yes "Update {{$type}} packages?"; then
          if [ "$1" = "xdg-open" ]; then
            "$@"
          else
            mux-wrap -w "$@"
            system tmux select-layout even-vertical
          fi
        fi
      }

      update apt        'sudo aptitude update && sudo aptitude upgrade'
      update flatpak    'flatpak update && flatpak uninstall --unused'
      update firmware   fwupdmgr update

      update asdf       'asdf update && asdf plugin update --all; echo; asdf global ruby latest:3; asdf global yarn latest; asdf install'
      update gem        'gem update && gem cleanup'
      update yarn       yarn global upgrade
      ;;
    # }}}

    dconf) # {{{
      local action="$1"
      shift

      if [ "$action" = "sync" ]; then
        status "{{Dumping dconf settings}}"
        run dconf dump >/dev/null

        if git status -s dconf | grep -q .; then
          echo
          warning "{{Found local changes:}}"
          git status -s dconf
          echo
          mux-wrap git diff dconf

          ask "{{Ignore changes?}}" || abort
          git checkout dconf
        fi

        status "{{Loading dconf settings}}"
        run dconf load >/dev/null
        exit
      fi

      if [ -n "$1" ]; then
        local paths=( "$@" )
      else
        local paths=( "$DOTFILES"/dconf/*.ini )
      fi

      for path in "${paths[@]}"; do
        if [ -f "$path" ] || [ "$path" != "${path%.ini}" ]; then
          local path=$( basename "$path" )
        fi

        local name=${path%.ini}
        local name=${name#/}
        local name=${name%/}
        local name=${name//\//.}

        local file="$DOTFILES/dconf/$name.ini"
        local path="/${name//./\/}/"

        if [ "$action" = "load" ]; then
          status "Loading {{$name}}"
          system dconf load "$path" < "$file"
        elif [ "$action" = "dump" ]; then
          status "Dumping {{$name}}"
          local output=$( system dconf dump "$path" )

          if [ -f "$file" ]; then
            local skip_markers=$( grep -E '^#( skip:.*)?$' "$file" )
            local skip_keys=$( echo "$skip_markers" | sed -rn 's/^# skip: +(.*)/^\1=/p' | tr "\n" "|" )
            local skip_sections=$( echo "$skip_markers" | sed -rn 's/^# skip:section +(.*)/\1/p' | tr "\n" "|" )

            if [ -n "$skip_keys" ]; then
              output=$( echo "$output" | grep -Ev "${skip_keys%|}" )
            fi

            if [ -n "$skip_sections" ]; then
              output=$( echo "$output" | awk "
                BEGIN { output = 1 };
                /^\[$( escape-regex "${skip_sections%|}" )\]$/ { output = 0; next };
                /^\[.*\]$/ { output = 1 };
                output
              " )
            fi

            if [ -n "$skip_markers" ]; then
              output=$( echo -e "$skip_markers\n\n$output" )
            fi
          fi

          echo "$output" > "$file"
        else
          usage
        fi
      done
      ;;
    # }}}

    vim|v) # {{{
      git edit config/nvim/init.vim
      ;;
    git|g)
      git edit config/git/config
      ;;
    tmux|t)
      git edit config/tmux/tmux.conf
      ;;
    # }}}
    *)
      git ignore-errors "$command" "$@"
      ;;
    # }}}
  esac
}

### main {{{

# find the dotfiles repository
if [ -z "$DOTFILES" ]; then
  if [ -d /etc/dotfiles ]; then
    DOTFILES=/etc/dotfiles
  elif [ -d ~/.dotfiles ]; then
    DOTFILES=~/.dotfiles
  else
    abort "Can't find repository in /etc/dotfiles or $HOME/.dotfiles, please set \$DOTFILES"
  fi
fi

# resolve symlinks
while [ -L "$DOTFILES" ]; do
  DOTFILES=$( readlink -f "$DOTFILES" )
done

if [ ! -f "$DOTFILES/bin/dotfiles" ]; then
  abort "Can't find dotfiles script in repository, please check your \$DOTFILES"
fi

COMMAND=
STATUS=0

# Parse arguments
while [ $# -gt 0 ]; do
  case "$1" in
    -v|--verbose) VERBOSE=1;;
       --path)    echo "$DOTFILES"; exit;;
    -*|help)      usage;;
    *)
      COMMAND=( "$@" )
      break
      ;;
  esac
  shift
done

if [ "${#COMMAND[@]}" ]; then
  run "${COMMAND[@]}"
  exit $STATUS
else
  usage
fi

### }}}
