#!/bin/bash

unset type matches display_matches count
unset list showall complete expand choice commit
dir=`echo "$PWD" | sed -r "s|^$HOME|~|"`

function usage {
  echo "Usage: git-edit [-l|--list] [-a|--all] [-c|--complete] [PATTERN] [CHOICE]"
  exit 255
}

for arg in "$@"; do
  if [ "${arg:0:1}" = "-" ]; then
    case "$arg" in
      -l|--list)
        list=1
        shift
        ;;
      -a|--all)
        showall=1
        shift
        ;;
      -c|--complete)
        complete=1
        shift
        exec 3>&1
        exec 1>&2
        ;;
      -e|--expand)
        expand=1
        shift
        ;;
      -*)
        usage
        ;;
    esac
  else
    break
  fi
done

# default Git options
GIT="git -c color.ui=always"
GIT_FORMAT="%C(yellow)[%h] %C(white)%s"
GIT_LOG=10

# colors
RESET=$(echo -ne '\e[0m')
WHITE=$(echo -ne '\e[1;37m')
RED=$(echo -ne '\e[1;31m')
GREEN=$(echo -ne '\e[1;32m')
YELLOW=$(echo -ne '\e[1;33m')
CYAN=$(echo -ne '\e[1;36m')
GRAY=$(echo -ne '\e[1;30m')

# cursor movement
COLUMNS=`tput cols`
LINES=`tput lines`
SAVE=$(echo -ne '\e[s')
RESTORE=$(echo -ne '\e[u')
ERASE=$(echo -ne '\e[2K')

function pick {
  head -n "$1" | tail -n 1
}

function is_git {
  git rev-parse &>/dev/null
}

function truncate {
  local length="${1:-$((COLUMNS - 8))}"

  sed -r "s/^(.{$((length - 4))}).{4,}$/\1.../"
}

function match_files {
  type="files"

  # expand '.' to '.*' and '/' to '.*/
  pattern=`echo "$pattern" | sed -r -e 's#(^|[^\])\.($|[^\*])#\1.*\2#g' -e 's#(^|[^/])/#\1.*/#g'`
  matches=`ag -l --ignore db/archive . --file-search-regex "$pattern" | sort`

  if [ -n "$matches" ]; then
    display_matches=`echo "$matches" | truncate | sed -r "s#($pattern)#$RED\1$RESET#g"`
    title="Found %count matches in %dir"
  else
    title="No matches in %dir"
  fi
}

function match_git_status {
  type="status"
  display_matches=`$GIT status -s`
  matches=`echo "$display_matches" | sed -r 's/.* ([^ ]+)$/\1/'`

  if [ -n "$matches" ]; then
    title="Found %count changes in %dir"
  else
    title="No changes in %dir"
  fi
}

function match_git_log {
  type="log"
  local log="$GIT log -n $GIT_LOG --all"
  matches=`$log --pretty=format:"%h"`

  if [ -n "$matches" ]; then
    display_matches=`$log --pretty=format:"$GIT_FORMAT" | truncate $((COLUMNS + 2))`
    title="Latest commits in %dir"
  else
    title="No commits in %dir"
  fi
}

function match_git_diff {
  type="diff"
  local diff="$GIT diff-tree -r --stat --no-commit-id ${commit:-HEAD}"
  matches=`$diff --name-only 2>/dev/null`

  if [ $? -ne 0 ]; then
    title="Unknown or ambiguous commit $YELLOW[$commit]$WHITE"
  elif [ -n "$matches" ]; then
    display_matches=`$diff --color | fgrep '|' | sed -r 's/^\s*//'`
    title=`$GIT show $commit -s --pretty=format:"$GIT_FORMAT" | truncate $COLUMNS`
  else
    title="No changes in commit $YELLOW[$commit]$WHITE"
  fi
}

function display_matches {
  echo "$title $GRAY[$type]$RESET"
  if [ $count -gt 0 ]; then
    if [ $count -eq 1 -a -n "$choice" ]; then
      display_matches=$(echo "$display_matches" | sed -r "s/^/`printf "%6d" $choice` /")
    elif [ $count -gt 0 ]; then
      display_matches=$(echo "$display_matches" | nl -s ' ')
    fi

    echo "$display_matches" | sed -r "s/^\s{2}(\s*)([0-9]+)/ \1$YELLOW[\2]$RESET/"

    if [ $count -gt $limit -a -z "$showall" ]; then
      echo "         ($((count - limit)) more...)"
    fi
  fi
}

# show a loading prompt for auto-completion
if [ -n "$complete" ]; then
  echo
  echo
  echo -ne "$SAVE"
  echo -n " $GREEN>$WHITE Loading...$RESET"
fi

input="$1"
pattern="$1"
choice="$2"

if [ -n "$choice" ] && [[ "$choice" =~ [^0-9] ]]; then
  usage
fi

# expand completions when the pattern ends with '%'
if [ "${pattern:$((${#pattern} - 1))}" = "%" ]; then
  expand=1
  pattern="${pattern:0:$((${#pattern} - 1))}"
fi

# check for trailing numbers
if echo -n "$pattern" | egrep -q '(^|.*#)[0-9]*$'; then
  # use the given number as the selected choice
  choice=`echo "$pattern"  | sed -r 's/(^|.*#)([0-9]*)$/\2/'`
  pattern=`echo "$pattern" | sed -r 's/#?[0-9]*$//'`

  if [ -z "$pattern" ]; then
    shift
    pattern="$1"
  fi
fi

# show all matches if the pattern ends with '!'
if [ "${pattern:$((${#pattern} - 1))}" = "!" ]; then
  showall=1
  pattern="${pattern:0:$((${#pattern} - 1))}"
fi

if ! is_git; then
  match_files
elif [ -z "$pattern" ]; then
  match_git_status
  if [ -z "$matches" ]; then
    match_git_log
    [ -n "$complete" ] && echo -n "@" >&3
  fi
elif [ "${input:0:1}" = "@" ]; then
  commit="$pattern"
  GIT_LOG=0
  while [ "${commit:0:1}" = "@" ]; do
    commit=${commit:1}
    let GIT_LOG+=10
  done
  limit=$GIT_LOG

  match_git_log

  if [ -n "$commit" ]; then
    if [[ "$commit" =~ ^[0-9]{,3}$ ]]; then
      commit=`echo "$matches" | pick $commit`
    fi
    match_git_diff
  fi
else
  match_files
fi

count=`echo "$matches" | grep -c .`
[ $count -eq 0 ] && display_matches=

# expand variables in title
title=$(echo "$title" | sed -r \
  -e "s|%count|$YELLOW$count$WHITE|g" \
  -e "s|%dir|$CYAN[$dir]$WHITE|g"
)

if [ $count -eq 0 ]; then
  title=" $RED>$WHITE $title$RESET"
else
  title=" $GREEN>$WHITE $title$RESET"
fi

if [ -n "$showall" ]; then
  limit="$count"
else
  # trim results to number of lines
  [ -v limit ] || limit=$((LINES - 4))
  [ $count -lt $limit ] && limit=$count
  [ $limit -le 0 ] && limit=1

  if [ $count -gt $limit ]; then
    display_matches=`echo -e "$display_matches" | head -n $limit`
  fi
fi

# select the given choice
if [ -n "$choice" ]; then
  count=1
  matches=`echo "$matches" | pick $choice`
  display_matches=`echo "$display_matches" | pick $choice`
fi

if [ -n "$list" ]; then
  display_matches
elif [ -n "$complete" ]; then
  # clear loading prompt
  echo -ne "$RESTORE"
  echo -ne "$ERASE"

  display_matches

  echo -ne " $GREEN>>>$RESET $input"

  if [ -n "$expand" ]; then
    echo "$matches" >&3
  fi
else
  if [ $count -eq 0 -o "$type" = "log" ]; then
    display_matches
  elif [ $count -eq 1 ]; then
    echo -e " $GREEN>>>$WHITE Editing $GREEN$matches$WHITE"
    sensible-editor "$matches"
  else
    read -p " $CYAN>>>$WHITE Edit $YELLOW$count$WHITE files?$RESET [Y/n] "
    [ "$REPLY" = "n" -o "$REPLY" = "N" ] && exit
    sensible-editor $matches
  fi
fi
